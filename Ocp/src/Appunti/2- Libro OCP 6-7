############################### CAPITOLO 6 ##################################

java.lang.Throwable
ha due sottoclassi: java.lang.Exception e java.lang.Error
java.lang.RuntimeException estend Exception 

----- UNCHECKED EXCEPTION -----------
Remember that a runtime exception, or UNCHECKED EXCEPTION, may be caught, but it is not required that it be caught. 

----- CHECKED EXCEPTION  ----------
A CHECKED EXCEPTION is any class that extends Exception but is not a runtime exception. Checked exceptions must follow the handle or declare rule where they are either
caught or thrown to the caller.

------ UNCHECKED EXCEPTION OCA  ----------
ArithmeticException Thrown by the JVM when code attempts to divide by zero.

ArrayIndexOutOfBoundsException Thrown by the JVM when code uses an illegal index to access an array.

ClassCastException Thrown by the JVM when an attempt is made to cast an object to a subclass of which it is not an instance.

IllegalArgumentException Thrown by the program to indicate that a method has been passed an illegal or inappropriate argument.

NullPointerException Thrown by the JVM when there is a null reference where an object is required.

NumberFormatException Thrown by the program when an attempt is made.

------ CHECKED EXCEPTION OCP  ----------
java.text.ParseException -    Converting a String to a number.

java.io.IOException
java.io.FileNotFound Exception	  -  Dealing with IO and NIO.2 issues. IOException is the parent class. You can assume any java.io exception is checked.
java.io.NotSerializable Exception

java.sql.SQLException    - Dealing with database issues. SQLException is the parent class. Again, you can assume any java.sql exception is checked.

------ UNCHECKED EXCEPTION OCA  ----------
java.lang.ArrayStoreException  -  Trying to store the wrong data type in an array.

java.time.DateTimeException   -   Receiving an invalid format string for a date.

java.util.MissingResourceException  -   Trying to access a key or resource bundle that does not exist.

java.lang.IllegalStateException 
java.lang.UnsupportedOperationException -  Attempting to run an invalid operation in collections and concurrency.

-------- EXAM TRICK ---------------
 Remember to pay attention that throw and throws aren’t reversed in the code that you see on the exam. 
 
It is illegal to declare a subclass exception in a catch block that is lower down in the list than a superclass
exception because it will be unreachable code.

Java will not allow you to declare a catch block for a checked exception type that cannot potentially be thrown by the try clause body.
--------- USING MULTI-CATCH  -------------------------------- 
catch(Exception1 e | Exception2 e | Exception3 e) // DOES NOT COMPILE
catch(Exception1 e1 | Exception2 e2 | Exception3 e3) // DOES NOT COMPILE
catch(Exception1 | Exception2 | Exception3 e)

La variabile dell'errore deve essere specificata una volta sola.

 catch (FileNotFoundException | IOException e) { } // DOES NOT COMPILE
 Perche  FileNotFoundException  è una sottoclasse di  IOException
 
catch(RuntimeException e) {
 e = new RuntimeException();   // non è un errore nel catch normale ma nel multi-catch il codice non compilA.
}

------------------ TRY-WITH-RESOURCES --------------------

try (BufferedReader r = Files.newBufferedReader(path1);
 BufferedWriter w = Files.newBufferedWriter(path2)) {
 // protected code
}
Le risporse specidicate nel try verranno chiuse automaticamente alla fine.



try (BufferedReader r = Files.newBufferedReader(path1);
 BufferedWriter w = Files.newBufferedWriter(path2)) {
 //protected code
} catch (IOException e) {
 // exeption handler
} finally {
 // finally block
}

Posso aggiungere anche nel TRY-WITH-RESOURCES un catch e un finally ma sono opzionali.
Nei miei catch e finally opzionali le risorse saranno gia chiuse.

Nel try non posso inserire cosa voglio io ma solo classi che implementano l'interfaccia java.lang.AutoCloseable implementando il metodo:
public void close() throws Exception;
Avendo l'interfaccia dichiarato direttamente Exception allora io quando l'implemento posso implementare qualsiasi sottoclasse di Exception. 


Ricordarti che le checked exception vanno gestite quindi se io scrivo una classe che implementa AutoCloseable e implemento una variante di 
close() che fa thrown di una checked exception come Exception allora in qualche modo nel TRY-WITH-RESOURCES sono obbligato a gestirla.


--------------- SUPPRESSED EXCEPTIONS ---------------
public class JammedTurkeyCage implements AutoCloseable {
   public void close() throws IllegalStateException {
       throw new IllegalStateException("Cage door does not close");
    } 
    
Quindi ho il mio AutoClosable JAMMEDTURKEYCAGE che mi lancia una UncheckedException

15: try (JammedTurkeyCage t = new JammedTurkeyCage()) {
16:     throw new IllegalStateException("turkeys ran off");
17: } catch (IllegalStateException e) {
18:     System.out.println("caught: " + e.getMessage());
19:     for (Throwable t: e.getSuppressed())
20:          System.out.println(t.getMessage());
21: }
Allora Quella che viene lanciata per prima è quella alla riga 16 e viene chiamata primary exception. Dopo aver lanciato quella 
java chiude la connessione ma chiamando close() lancia una seconda eccezzione oramai chiamata  suppressed exception. 
Output: 
caught: turkeys ran off
Cage door does not close

-----------
22: try (JammedTurkeyCage t = new JammedTurkeyCage()) {
23:     throw new RuntimeException("turkeys ran off");
24: } catch (IllegalStateException e) {
25:     System.out.println("caught: " + e.getMessage());
26: }
Se faccio cosi invcece la mia eccezzione della riga 23 non viene catchata e se ne occupera il metodo prima che mi stamperà entrambe.

27: try (JammedTurkeyCage t1 = new JammedTurkeyCage();
28:     JammedTurkeyCage t2 = new JammedTurkeyCage()) {
29:           System.out.println("turkeys entered cages");
30: } catch (IllegalStateException e) {
31:     System.out.println("caught: " + e.getMessage());
32:     for (Throwable t: e.getSuppressed())
33:           System.out.println(t.getMessage());
34: }
On line 29, the turkeys enter the cages without exception. Then Java tries to close both cages automatically. t2 is closed first, since Java closes resources in the reverse order from
which it created them. This throws an exception. Since it is the first exception to occur, it becomes the primary exception. Then t1 is closed. Since an exception has already been
thrown, this one becomes a suppressed exception. The output is

turkeys entered cages
caught: Cage door does not close
Cage door does not close


Infine se alla fine di tutto dentro un finally lancio ancora un ezccezione predo tutte le altre perche java fa schifo. 


-------------------- ASSERTIONS ---------------------------------
An assertion is a Boolean expression that you place at a point in your code where you expect something to be true. 

Syntax:  assert boolean_expression;     assert boolean_expression: error_message;
If assertions are enabled and the boolean expression is false , then our assertion is invalid and a java.lang.AssertionError is thrown.

By default, assert statements are ignored by the JVM at runtime. To enable assertions, use
the -enableassertions or -ea flag on the command line    

1 java -ea:com.wiley.demos... my.programs.Main
The three dots means any class in the specifi ed package or subpackages. You can also enable assertions for a specific class:
2 java -ea:com.wiley.demos.TestColors my.programs.Main

You can disable assertions using the -disableassertions (or -da ) fl ag for a specific class or package that was previously enabled. 

ex:  java -ea:com.wiley.demos... -da:com.wiley.demos.TestColors my.programs.Main 

Attento all'esame al codice che presenta assertion ma non è enabled perche in quel caso java le ignora.

############################### CAPITOLO 7 ##################################
I system threads sono in generale i thread della JVM tipo il Garbage Collector ha un suo thread. Quando si dice che noi non dovremmo mai 
chatchare Errors è perche vengono lanciati dai system threads e per esempio anche se fossimo in OOM e venisse lanciato un Error e noi lo 
catchassimo non servirebbe a nulla perche non potremmo fare molto senza memoria. 

Alternatively, a user-defi ned thread is one created by the application developer to accomplish a specific task.

A CONTEXT SWITCH is the process of storing a thread’s current state and later restoring the state of the thread to continue execution

Finally, a thread can interrupt or supersede another thread if it has a higher thread priority than the other thread. A thread priority is a numeric value associated with a thread
that is taken into consideration by the thread scheduler when determining which threads should currently be executing.

Thread.MIN_PRIORITY 1
Thread.NORM_PRIORITY 5
Thread.MAX_PRIORITY 10


----------  RUNNABLE --------------
@FunctionalInterface public interface Runnable {
    void run();
}
------------- THREAD ---------------

Remember that order of thread execution is not often guaranteed. The exam commonly presents questions in which multiple tasks are started at
the same time, and you must determine the result. 
Abbiamo due modi per usare i threads: 

1. Implementaimo Runnable e chiamiamo il metodo .start() che farà partire il Thread che eseguirà il corpo del metodo run()
public class PrintData implements Runnable {
   public void run() {
      for(int i=0; i<3; i++)
      System.out.println("Printing record: "+i); 
   }
   public static void main(String[] args) {
      (new Thread(new PrintData())).start();   //fa partire il nuovo thread
   }
}

2. Estendiamo la classe thread e sovrascriviamo il metodo run, poi chiamiamo start() che creerà un nuovo thread che eseguirà il corpo di run()
public class ReadInventoryThread extends Thread {
    public void run() {
       System.out.println("Printing zoo inventory");
    }
    public static void main(String[] args) {
       (new ReadInventoryThread()).start();
    }
}

Poi li chiamo cosi:
public static void main(String[] args) {
   System.out.println("begin");
   (new ReadInventoryThread()).start();
   (new Thread(new PrintData())).start();
   (new ReadInventoryThread()).start();
 }  
All'esame stai attento che i vari .start() vengano chiamati perche è possibile che ti freghino non chimandoli ma chiamando 
i .run() non creando cosi dei thread ma delle esecuzioni del codice sequenziali. 

Thread.sleep(1000); // 1 SECOND     it may throw A InterruptedException!!

---------------------------- EXECUTORSERVICE ---------------------------

----------------------SINGLE-THREAD EXECUTOR --------------------
Since EXECUTORSERVICE is an interface. The Concurrency API includes the Executors factory class that can be used to create instances
of the ExecutorService object.
ExecutorService service = Executors.newSingleThreadExecutor();

La logica la inseriamo dentro un try catch. Dove nel try innizializziamo in nostro ExecutorService service e eseguiamo azioni
diverse su questo singolo thread traimite il metodo .execute()  
   service.execute(() -> System.out.println("Printing zoo inventory"));
nel finally: 
   if(service != null) service.shutdown();

--------------------Shutting Down a Thread Executor------------------
Once you have finished using a thread executor, it is important that you call the shutdown() method. A thread executor creates a non-daemon thread on the first task that
is executed, so failing to call shutdown() will result in your application never terminating.

Quando creo un executor il suo stato è  ATTIVO 
- Accepts New Tasks
- Executes Tasks
- isShutdown() = false
- isTerminated() = false

Quando chiamo il metodo shutdown() il suo stato è SHUTTING DOWN
- Rejects New Tasks
- Executes Tasks
- isShutdown() = true
- isTerminated() = false
Qui l'executor non inizia altri task ma quelli che ha iniziato li porta a termine.

Quando tutti i task sono finiti il suop stato è 
- Rejects New Tasks (Throwing a  RejectedExecutionException)
- No Tasks Running
- isShutdown() = true
- isTerminated() = true
For the exam, you should be aware that shutdown() does not actually stop any tasks that have already been submitted to the thread executor. 
 
The ExecutorService provides a method called shutdownNow(), which attempts to stop all running tasks and discards any that have not been started yet.
Note that shutdownNow() attempts to stop all running tasks. 

---------------  SUBMITTING TASKS  ---------------------------
The EXECUTE() method takes a Runnable lambda expression or instance and completes the task asynchronously. 

1 void execute(Runnable command) 
Executes a Runnable task at some point in the future
2 Future<?> submit(Runnable task) 
Executes a Runnable task at some point in the future and returns a Future representing the task
3 <T> Future<T> submit(Callable<T> task) 
Executes a Callable task at some point in the future and returns a Future representing the pending results of the task
4 <T> List<Future<T>> invokeAll( Collection<? extends Callable<T>> tasks) throws InterruptedException
Executes the given tasks, synchronously returning the results of all tasks as a Collection of Future objects, in the same order they were in the original collection
5 <T> T invokeAny( Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException
Executes the given tasks, synchronously returning the result of one of finished tasks,cancelling any unfinished tasks

------------ SUBMITTING TASK COLLECTIONS  -------------------------
 invokeAll() and invokeAny()
Both of these methods take a Collection object containing a list of tasks to execute.

The invokeAll() method executes all tasks in a provided collection and returns a List of ordered Future objects, with one Future object corresponding to each submitted task,
in the order they were in the original collection. Even though Future.isDone() returns true for each element in the returned List,
a task could have completed normally or thrown an exception.

The invokeAny() method executes a collection of tasks and returns the result of one of the tasks that successfully completes execution, cancelling all unfinished tasks. 
While the first task to finish is often returned, this behavior is not guaranteed, as any completed task can be returned by this method.

Finally, the invokeAll() method will wait indefinitely until all tasks are complete, while the invokeAny() method will wait indefinitely until at least one task completes.

------------- FUTURE --------------------------------------------
Future<?> future = service.submit(() -> System.out.println("Hello Zoo"));

1. boolean isDone()
Returns true if the task was completed, threw an exception, or was cancelled.

2. boolean isCancelled() 
Returns true if the task was cancelled before it completely normally.

3. boolean cancel() 
Attempts to cancel execution of the task.

4. V get() 
Retrieves the result of a task, waiting endlessly if it is not yet available.

V get(long timeout, TimeUnit unit)
Retrieves the result of a task, waiting the specified amount of time. If the result is not ready by the time the timeout is reached, a checked TimeoutException will be thrown.


-----------------  CALLABLE   ----------------------

@FunctionalInterface public interface Callable<V> {
 	V call() throws Exception;
}
