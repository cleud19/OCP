############################### CAPITOLO 6 ##################################

java.lang.Throwable
ha due sottoclassi: java.lang.Exception e java.lang.Error
java.lang.RuntimeException estend Exception 

----- UNCHECKED EXCEPTION -----------
Remember that a runtime exception, or UNCHECKED EXCEPTION, may be caught, but it is not required that it be caught. 

----- CHECKED EXCEPTION  ----------
A CHECKED EXCEPTION is any class that extends Exception but is not a runtime exception. Checked exceptions must follow the handle or declare rule where they are either
caught or thrown to the caller.

------ UNCHECKED EXCEPTION OCA  ----------
ArithmeticException Thrown by the JVM when code attempts to divide by zero.

ArrayIndexOutOfBoundsException Thrown by the JVM when code uses an illegal index to access an array.

ClassCastException Thrown by the JVM when an attempt is made to cast an object to a subclass of which it is not an instance.

IllegalArgumentException Thrown by the program to indicate that a method has been passed an illegal or inappropriate argument.

NullPointerException Thrown by the JVM when there is a null reference where an object is required.

NumberFormatException Thrown by the program when an attempt is made.

------ CHECKED EXCEPTION OCP  ----------
java.text.ParseException -    Converting a String to a number.

java.io.IOException
java.io.FileNotFound Exception	  -  Dealing with IO and NIO.2 issues. IOException is the parent class. You can assume any java.io exception is checked.
java.io.NotSerializable Exception

java.sql.SQLException    - Dealing with database issues. SQLException is the parent class. Again, you can assume any java.sql exception is checked.

------ UNCHECKED EXCEPTION OCA  ----------
java.lang.ArrayStoreException  -  Trying to store the wrong data type in an array.

java.time.DateTimeException   -   Receiving an invalid format string for a date.

java.util.MissingResourceException  -   Trying to access a key or resource bundle that does not exist.

java.lang.IllegalStateException 
java.lang.UnsupportedOperationException -  Attempting to run an invalid operation in collections and concurrency.

-------- EXAM TRICK ---------------
 Remember to pay attention that throw and throws aren’t reversed in the code that you see on the exam. 
 
It is illegal to declare a subclass exception in a catch block that is lower down in the list than a superclass
exception because it will be unreachable code.

Java will not allow you to declare a catch block for a checked exception type that cannot potentially be thrown by the try clause body.
--------- USING MULTI-CATCH  -------------------------------- 
catch(Exception1 e | Exception2 e | Exception3 e) // DOES NOT COMPILE
catch(Exception1 e1 | Exception2 e2 | Exception3 e3) // DOES NOT COMPILE
catch(Exception1 | Exception2 | Exception3 e)

La variabile dell'errore deve essere specificata una volta sola.

 catch (FileNotFoundException | IOException e) { } // DOES NOT COMPILE
 Perche  FileNotFoundException  è una sottoclasse di  IOException
 
catch(RuntimeException e) {
 e = new RuntimeException();   // non è un errore nel catch normale ma nel multi-catch il codice non compilA.
}

------------------ TRY-WITH-RESOURCES --------------------

try (BufferedReader r = Files.newBufferedReader(path1);
 BufferedWriter w = Files.newBufferedWriter(path2)) {
 // protected code
}
Le risporse specidicate nel try verranno chiuse automaticamente alla fine.



try (BufferedReader r = Files.newBufferedReader(path1);
 BufferedWriter w = Files.newBufferedWriter(path2)) {
 //protected code
} catch (IOException e) {
 // exeption handler
} finally {
 // finally block
}

Posso aggiungere anche nel TRY-WITH-RESOURCES un catch e un finally ma sono opzionali.
Nei miei catch e finally opzionali le risorse saranno gia chiuse.

Nel try non posso inserire cosa voglio io ma solo classi che implementano l'interfaccia java.lang.AutoCloseable implementando il metodo:
public void close() throws Exception;
Avendo l'interfaccia dichiarato direttamente Exception allora io quando l'implemento posso implementare qualsiasi sottoclasse di Exception. 


Ricordarti che le checked exception vanno gestite quindi se io scrivo una classe che implementa AutoCloseable e implemento una variante di 
close() che fa thrown di una checked exception come Exception allora in qualche modo nel TRY-WITH-RESOURCES sono obbligato a gestirla.


--------------- SUPPRESSED EXCEPTIONS ---------------
public class JammedTurkeyCage implements AutoCloseable {
   public void close() throws IllegalStateException {
       throw new IllegalStateException("Cage door does not close");
    } 
    
Quindi ho il mio AutoClosable JAMMEDTURKEYCAGE che mi lancia una UncheckedException

15: try (JammedTurkeyCage t = new JammedTurkeyCage()) {
16:     throw new IllegalStateException("turkeys ran off");
17: } catch (IllegalStateException e) {
18:     System.out.println("caught: " + e.getMessage());
19:     for (Throwable t: e.getSuppressed())
20:          System.out.println(t.getMessage());
21: }
Allora Quella che viene lanciata per prima è quella alla riga 16 e viene chiamata primary exception. Dopo aver lanciato quella 
java chiude la connessione ma chiamando close() lancia una seconda eccezzione oramai chiamata  suppressed exception. 
Output: 
caught: turkeys ran off
Cage door does not close

-----------
22: try (JammedTurkeyCage t = new JammedTurkeyCage()) {
23:     throw new RuntimeException("turkeys ran off");
24: } catch (IllegalStateException e) {
25:     System.out.println("caught: " + e.getMessage());
26: }
Se faccio cosi invcece la mia eccezzione della riga 23 non viene catchata e se ne occupera il metodo prima che mi stamperà entrambe.

27: try (JammedTurkeyCage t1 = new JammedTurkeyCage();
28:     JammedTurkeyCage t2 = new JammedTurkeyCage()) {
29:           System.out.println("turkeys entered cages");
30: } catch (IllegalStateException e) {
31:     System.out.println("caught: " + e.getMessage());
32:     for (Throwable t: e.getSuppressed())
33:           System.out.println(t.getMessage());
34: }
On line 29, the turkeys enter the cages without exception. Then Java tries to close both cages automatically. t2 is closed first, since Java closes resources in the reverse order from
which it created them. This throws an exception. Since it is the first exception to occur, it becomes the primary exception. Then t1 is closed. Since an exception has already been
thrown, this one becomes a suppressed exception. The output is

turkeys entered cages
caught: Cage door does not close
Cage door does not close


Infine se alla fine di tutto dentro un finally lancio ancora un ezccezione predo tutte le altre perche java fa schifo. 


-------------------- ASSERTIONS ---------------------------------
An assertion is a Boolean expression that you place at a point in your code where you expect something to be true. 

Syntax:  assert boolean_expression;     assert boolean_expression: error_message;
If assertions are enabled and the boolean expression is false , then our assertion is invalid and a java.lang.AssertionError is thrown.

By default, assert statements are ignored by the JVM at runtime. To enable assertions, use
the -enableassertions or -ea flag on the command line    

1 java -ea:com.wiley.demos... my.programs.Main
The three dots means any class in the specifi ed package or subpackages. You can also enable assertions for a specific class:
2 java -ea:com.wiley.demos.TestColors my.programs.Main

You can disable assertions using the -disableassertions (or -da ) fl ag for a specific class or package that was previously enabled. 

ex:  java -ea:com.wiley.demos... -da:com.wiley.demos.TestColors my.programs.Main 

Attento all'esame al codice che presenta assertion ma non è enabled perche in quel caso java le ignora.

############################### CAPITOLO 7 ##################################
I system threads sono in generale i thread della JVM tipo il Garbage Collector ha un suo thread. Quando si dice che noi non dovremmo mai 
chatchare Errors è perche vengono lanciati dai system threads e per esempio anche se fossimo in OOM e venisse lanciato un Error e noi lo 
catchassimo non servirebbe a nulla perche non potremmo fare molto senza memoria. 

Alternatively, a user-defi ned thread is one created by the application developer to accomplish a specific task.

A CONTEXT SWITCH is the process of storing a thread’s current state and later restoring the state of the thread to continue execution

Finally, a thread can interrupt or supersede another thread if it has a higher thread priority than the other thread. A thread priority is a numeric value associated with a thread
that is taken into consideration by the thread scheduler when determining which threads should currently be executing.

Thread.MIN_PRIORITY 1
Thread.NORM_PRIORITY 5
Thread.MAX_PRIORITY 10


----------  RUNNABLE --------------
@FunctionalInterface public interface Runnable {
    void run();
}
------------- THREAD ---------------

Remember that order of thread execution is not often guaranteed. The exam commonly presents questions in which multiple tasks are started at
the same time, and you must determine the result. 
Abbiamo due modi per usare i threads: 

1. Implementaimo Runnable e chiamiamo il metodo .start() che farà partire il Thread che eseguirà il corpo del metodo run()
public class PrintData implements Runnable {
   public void run() {
      for(int i=0; i<3; i++)
      System.out.println("Printing record: "+i); 
   }
   public static void main(String[] args) {
      (new Thread(new PrintData())).start();   //fa partire il nuovo thread
   }
}

2. Estendiamo la classe thread e sovrascriviamo il metodo run, poi chiamiamo start() che creerà un nuovo thread che eseguirà il corpo di run()
public class ReadInventoryThread extends Thread {
    public void run() {
       System.out.println("Printing zoo inventory");
    }
    public static void main(String[] args) {
       (new ReadInventoryThread()).start();
    }
}

Poi li chiamo cosi:
public static void main(String[] args) {
   System.out.println("begin");
   (new ReadInventoryThread()).start();
   (new Thread(new PrintData())).start();
   (new ReadInventoryThread()).start();
 }  
All'esame stai attento che i vari .start() vengano chiamati perche è possibile che ti freghino non chimandoli ma chiamando 
i .run() non creando cosi dei thread ma delle esecuzioni del codice sequenziali. 

Thread.sleep(1000); // 1 SECOND     it may throw A InterruptedException!!

---------------------------- EXECUTORSERVICE ---------------------------

----------------------SINGLE-THREAD EXECUTOR --------------------
Since EXECUTORSERVICE is an interface. The Concurrency API includes the Executors factory class that can be used to create instances
of the ExecutorService object.
ExecutorService service = Executors.newSingleThreadExecutor();

La logica la inseriamo dentro un try catch. Dove nel try innizializziamo in nostro ExecutorService service e eseguiamo azioni
diverse su questo singolo thread traimite il metodo .execute()  
   service.execute(() -> System.out.println("Printing zoo inventory"));
nel finally: 
   if(service != null) service.shutdown();

--------------------Shutting Down a Thread Executor------------------
Once you have finished using a thread executor, it is important that you call the shutdown() method. A thread executor creates a non-daemon thread on the first task that
is executed, so failing to call shutdown() will result in your application never terminating.

Quando creo un executor il suo stato è  ATTIVO 
- Accepts New Tasks
- Executes Tasks
- isShutdown() = false
- isTerminated() = false

Quando chiamo il metodo shutdown() il suo stato è SHUTTING DOWN
- Rejects New Tasks
- Executes Tasks
- isShutdown() = true
- isTerminated() = false
Qui l'executor non inizia altri task ma quelli che ha iniziato li porta a termine.

Quando tutti i task sono finiti il suop stato è 
- Rejects New Tasks (Throwing a  RejectedExecutionException)
- No Tasks Running
- isShutdown() = true
- isTerminated() = true
For the exam, you should be aware that shutdown() does not actually stop any tasks that have already been submitted to the thread executor. 
 
The ExecutorService provides a method called shutdownNow(), which attempts to stop all running tasks and discards any that have not been started yet.
Note that shutdownNow() attempts to stop all running tasks. 

---------------  SUBMITTING TASKS  ---------------------------
The EXECUTE() method takes a Runnable lambda expression or instance and completes the task asynchronously. 

1 void execute(Runnable command) 
Executes a Runnable task at some point in the future
2 Future<?> submit(Runnable task) 
Executes a Runnable task at some point in the future and returns a Future representing the task
3 <T> Future<T> submit(Callable<T> task) 
Executes a Callable task at some point in the future and returns a Future representing the pending results of the task
4 <T> List<Future<T>> invokeAll( Collection<? extends Callable<T>> tasks) throws InterruptedException
Executes the given tasks, synchronously returning the results of all tasks as a Collection of Future objects, in the same order they were in the original collection
5 <T> T invokeAny( Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException
Executes the given tasks, synchronously returning the result of one of finished tasks,cancelling any unfinished tasks

------------ SUBMITTING TASK COLLECTIONS  -------------------------
 invokeAll() and invokeAny()
Both of these methods take a Collection object containing a list of tasks to execute.

The invokeAll() method executes all tasks in a provided collection and returns a List of ordered Future objects, with one Future object corresponding to each submitted task,
in the order they were in the original collection. Even though Future.isDone() returns true for each element in the returned List,
a task could have completed normally or thrown an exception.

The invokeAny() method executes a collection of tasks and returns the result of one of the tasks that successfully completes execution, cancelling all unfinished tasks. 
While the first task to finish is often returned, this behavior is not guaranteed, as any completed task can be returned by this method.

Finally, the invokeAll() method will wait indefinitely until all tasks are complete, while the invokeAny() method will wait indefinitely until at least one task completes.

------------- FUTURE --------------------------------------------
Future<?> future = service.submit(() -> System.out.println("Hello Zoo"));

1. boolean isDone()
Returns true if the task was completed, threw an exception, or was cancelled.

2. boolean isCancelled() 
Returns true if the task was cancelled before it completely normally.

3. boolean cancel() 
Attempts to cancel execution of the task.

4. V get() 
Retrieves the result of a task, waiting endlessly if it is not yet available.

V get(long timeout, TimeUnit unit)
Retrieves the result of a task, waiting the specified amount of time. If the result is not ready by the time the timeout is reached, a checked TimeoutException will be thrown.


-----------------  CALLABLE   ----------------------

@FunctionalInterface public interface Callable<V> {
 	V call() throws Exception;
}

1: service.submit(() -> {Thread.sleep(1000); return null;});
2: service.submit(() -> {Thread.sleep(1000);});  //not compile

Thread.sleep() lancia una checked exception InterruptedException. Nella chimata 1 ilcodice compila poiche essendo una Callable call permette le eccezioni. 
La chiamata 2 essendo interpretata come un runnable non avendo il tipo di ritorno non compila perche run non accetta eccezioni.
 
Since Callable supports a return type when used with ExecutorService, it is often preferred over Runnable when using the Concurrency API.

Future<Integer> result = service.submit(() -> 30+11); // è un callable perche ha un ritorno e posso leggerlo
System.out.println(result.get());

---------------- WAITING FOR ALL TASKS TO FINISH ------------------
First, we shut down the thread executor using the shutdown() method. Next, we use the awaitTermination(long timeout, TimeUnit unit).

if(service != null) {
    service.awaitTermination(1, TimeUnit.MINUTES);
    // Check whether all tasks are finished
    if(service.isTerminated())
       System.out.println("All tasks finished");
}

------------- SCHEDULING TASKS ---------------------------------------

ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();

Note that we could implicitly cast an instance of ScheduledExecutorService to ExecutorService, although doing so would remove access to the scheduled methods that we want to use.
Questo perche ScheduledExecutorService è una sottointerfaccia di ExecutorService.

1 schedule(Callable<V> callable,long delay, TimeUnit unit)    ritorna un  ScheduledFuture<V> 
Creates and executes a Callable task after the given delay

2. schedule(Runnable command,long delay, TimeUnit unit)  ritorna un  ScheduledFuture<V> 
Creates and executes a Runnable task after the given delay

3. scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)
Creates and executes a Runnable task after the given initial delay, creating a new task every period value that passes.

4. scheduleAtFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)
Creates and executes a Runnable task after the given initial delay and subsequently with the given delay between the termination of one execution and the commencement of the next.


ScheduledFuture<V> is identical to the Future<V> class, except that it includes a getDelay() method that returns the delay set when the process was created. 

 ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
 Runnable task1 = () -> System.out.println("Hello Zoo");
 Callable<String> task2 = () -> "Monkey";
 Future<?> result1 = service.schedule(task1, 10, TimeUnit.SECONDS);
 Future<?> result2 = service.schedule(task2, 8, TimeUnit.MINUTES); 
 
service.scheduleAtFixedRate(command,5,1,TimeUnit.MINUTE);   //se il mio runnable command ci mette sempre piu di 5 minuti creero una lista infinita di task.
service.scheduleAtFixedDelay(command,0,2,TimeUnit.MINUTE); 


-----------------  INCREASING CONCURRENCY WITH POOLS ----------------------------
A thread pool is a group of pre-instantiated reusable threads that are available to perform a set of arbitrary tasks.

1 newSingleThreadExecutor() --> ExecutorService 
Creates a single-threaded executor that uses a single worker thread operating off an unbounded queue. Results are processed sequentially in the order in which they are submitted.

2 newSingleThreadScheduledExecutor() -->  Scheduled ExecutorService
Creates a single-threaded executor that can schedule commands to run after a given delay or to execute periodically.

3 newCachedThreadPool() --> ExecutorService 
Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available.
L'uso di questo è sconsigliato per thread le cui esecuzuini impiegano molto tempo perche potrebbe crearne troppi nel tempo. 

4 newFixedThreadPool(int nThreads) --> ExecutorService 
Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.

5 newScheduledThreadPool(int nThreads) --> Scheduled ExecutorService
Creates a thread pool that can schedule commands to run after a given delay or to execute periodically.


ex: 
ScheduledExecutorService service = Executors.newScheduledThreadPool(10);
service.scheduleAtFixedRate(command,3,1,TimeUnit.MINUTE);

Whereas with a single-thread executor and a five-minute task execution time, an endless set of tasks would be scheduled over time. With a pooled executor, this can be avoided. If
the pool size is sufficiently large, 10 for example, then as each thread finishes, it is returned to the pool and results in new threads available for the next tasks as they come up.

----------------------------------------------------SYNCHRONIZING DATA ACCESS -------------------------------------------------
AtomicBoolean        A boolean value that may be updated atomically
AtomicInteger        An int value that may be updated atomically
AtomicIntegerArray   An int array in which elements may be updated atomically
AtomicLong           A long value that may be updated atomically
AtomicLongArray      A long array in which elements may be updated atomically
AtomicReference      A generic object reference that may be updated atomically
AtomicReferenceArray An array of generic object references in which elements may beupdated atomically

Classi dove la lettura del valore e la modifica del valore è un unica azione atomica  e finche io non ho finito di scrivere il valore quall'altro non puo nemmeno leggerlo.
Su queste classi dovrò operare con dei metodi eccone alcuni da conoscere: 
1 get() Retrieve the current value
2 set() Set the given value, equivalent to the assignment = operator
3 getAndSet() Atomically sets the new value and returns the old value
4 incrementAndGet() For numeric classes, atomic pre-increment operation equivalent to ++value
5 getAndIncrement() For numeric classes, atomic post-increment operation equivalent to value++
6 decrementAndGet() For numeric classes, atomic pre-decrement operation equivalent to --value
7 getAndDecrement() For numeric classes, atomic post-decrement operation equivalent to value--


public class SheepManager {
    //private int sheepCount = 0;
    private AtomicInteger sheepCount = new AtomicInteger(0); 
    private void incrementAndReport() {
       // System.out.print((++sheepCount)+" ");
       System.out.print(sheepCount.incrementAndGet()+" "); 
    }
    public static void main(String[] args) {
        ExecutorService service = null;
        try {
            service = Executors.newFixedThreadPool(20);
            SheepManager manager = new SheepManager();
            for(int i=0; i<10; i++)
               service.submit(() -> manager.incrementAndReport());
        } finally {
            if(service != null) service.shutdown();
        }
    }
}
Vediamo cosi che avremo printatti tutti i numeri da 1 a 10 , mentre nel caso di prima era possibile avere 10 numeri da 1 a 8 con due 1. Questo perche due thread leggevano contemporanemante 0
aggiornavano contemporaneamente a 1 e stampavano entrambi 1. 

Solo che ora l'azione di incremento e lettura è atomica. Ma l'azione di stampa no, quindi potrebbe stampare prima il 2 e poi 1. Perche il thread che stampa 2 potrebbe essere avvantaggiato dallo scheduler in
qualche modo per qualche strano motivo. 

------------SYNCHRONIZED----------------------

private void incrementAndReport() {
    synchronized(this) {
        System.out.print((++sheepCount)+" ");
    }
 }
Con synchronized risolvo senza nemmeno usare AtomicInteger. 
In questo modo sto dichiarando this come monitor. 
Ogni thread che entra in quella parte di codice deve controllare il monitor se un altro thread ha il lock su quel monitor allora il nuovo thread deve aspettare che quello finisca e liberi il monitor.

Possiamo usare anche questa sintassi 
 private synchronized void incrementAndReport() {
     System.out.print((++sheepCount)+" ");
 } 
Che introduce il modifier synchronized che rende sincronizzato il metodo e l'oggetto su cui andrà a sincronizzare rendendolo un monitor è automaticamente this. 

Possiamo aggiungere il modifier synchronized anche metodi statici , in quel caso l'oggetto usato come monitor non è l'istanza della classe essendo un metoto statico ma l'oggetto classe in se. 
esempio:
1:
public static void printDaysWork() {
    synchronized(SheepManager.class) {
        System.out.print("Finished work");
    }
}
2:
public static synchronized void printDaysWork() {
    System.out.print("Finished work");
}

---------------------------------- USING CONCURRENT COLLECTIONS -----------------------
public class ZooManager {
    private Map<String,Object> foodData = new ConcurrentHashMap<String,Object>();  // in questo esempio è bastato solo questo

    public void put(String key, String value) {
       foodData.put(key, value);
    }
    public Object get(String key) {
       return foodData.get(key);
    }
}


When two threads try to modify the same non-concurrent collection, the JVM may throw a ConcurrentModificationException at runtime.
Puo succedere anche con un solo thread 
Map<String, Object> foodData = new HashMap<String, Object>();
foodData.put("penguin", 1);
foodData.put("flamingo", 2);
for(String key: foodData.keySet()){ foodData.remove(key);}
Questo codice lancia ConcurrentModificationException perche foodData.heySet() al secondo giro non è aggiornato con il nuovo stato di foodData. 
Per risolverlo basta inizializzare foodData come un  ConcurrentHashMap<String, Object>();

If all of the threads are accessing an established immutable or read-only collection, a concurrent collection class is not required


                                                             Eements Ordered? Sorted? Blocking?
1 ConcurrentHashMap  -  ConcurrentMap                           No No No
2 ConcurrentLinkedDeque - Deque                                 Yes No No
3 ConcurrentLinkedQueue - Queue                                 Yes No No
4 ConcurrentSkipListMap - ConcurrentMap SortedMap NavigableMap  Yes Yes No
5 ConcurrentSkipListSet - SortedSet NavigableSet                Yes Yes No
6 CopyOnWriteArrayList - List                                   Yes No No
7 CopyOnWriteArraySet - Set                                     No No No
8 LinkedBlockingDeque - BlockingQueue BlockingDeque             Yes No Yes
9 LinkedBlockingQueue - BlockingQueue                           Yes No Yes

in it.cla.test.alvolo.dequeTest ci sono dei esempi dei 2 e 3. 

8 e 9 
 LINKEDBLOCKINGQUEUE and LINKEDBLOCKINGDEQUE. The BlockingQueue is just like a regular Queue, except that it includes methods that will wait a specific amount of time to complete an operation
 
-------- BLOCKINGQUEUE WAITING METHODS -------------
 - offer(E e, long timeout, TimeUnit unit)
Adds item to the queue waiting the specified time, returning false if time elapses before space is available
 - poll(long timeout, TimeUnit unit)
Retrieves and removes an item from the queue, waiting the specified time, returning null if the time elapses before the item is available.

NB can each throw a checked InterruptedException. 

try {
    BlockingQueue<Integer> blockingQueue = new LinkedBlockingQueue<>();
    blockingQueue.offer(39);
    blockingQueue.offer(3, 4, TimeUnit.SECONDS);
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll(10, TimeUnit.MILLISECONDS));
} catch (InterruptedException e) {
 // Handle interruption
}
---------BLOCKINGQUEUE WAITING METHODS -------------
- offerFirst(E e, long timeout, TimeUnit unit)
Adds an item to the front of the queue, waiting a specified time, returning false if time elapses before space is available
- offerLast(E e, long timeout, TimeUnit unit)
Adds an item to the tail of the queue, waiting a specified time, returning false if time elapses before space is available
- pollFirst(long timeout, TimeUnit unit)
Retrieves and removes an item from the front of the queue, waiting the specified time, returning null if the time elapses before the item is available
- pollLast(long timeout, TimeUnit unit)
Retrieves and removes an item from the tail of the queue, waiting the specified time, returning null if the time elapses before the item is available

NB can each throw a checked InterruptedException. 

