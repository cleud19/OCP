########################################################################################### CAPITOLO 6 ##############################################################################################

java.lang.Throwable
ha due sottoclassi: java.lang.Exception e java.lang.Error
java.lang.RuntimeException estend Exception 

--------------------------- UNCHECKED EXCEPTION ---------------------------------
Remember that a runtime exception, or UNCHECKED EXCEPTION, may be caught, but it is not required that it be caught. 

--------------------------- CHECKED EXCEPTION  --------------------------------
A CHECKED EXCEPTION is any class that extends Exception but is not a runtime exception. Checked exceptions must follow the handle or declare rule where they are either
caught or thrown to the caller.

---------------------------- UNCHECKED EXCEPTION OCA  --------------------------------
ArithmeticException Thrown by the JVM when code attempts to divide by zero.

ArrayIndexOutOfBoundsException Thrown by the JVM when code uses an illegal index to access an array.

ClassCastException Thrown by the JVM when an attempt is made to cast an object to a subclass of which it is not an instance.

IllegalArgumentException Thrown by the program to indicate that a method has been passed an illegal or inappropriate argument.

NullPointerException Thrown by the JVM when there is a null reference where an object is required.

NumberFormatException Thrown by the program when an attempt is made.

------ CHECKED EXCEPTION OCP  ----------
java.text.ParseException -    Converting a String to a number.

java.io.IOException
java.io.FileNotFound Exception	  -  Dealing with IO and NIO.2 issues. IOException is the parent class. You can assume any java.io exception is checked.
java.io.NotSerializable Exception

java.sql.SQLException    - Dealing with database issues. SQLException is the parent class. Again, you can assume any java.sql exception is checked.

------ UNCHECKED EXCEPTION OCA  ----------
java.lang.ArrayStoreException  -  Trying to store the wrong data type in an array.

java.time.DateTimeException   -   Receiving an invalid format string for a date.

java.util.MissingResourceException  -   Trying to access a key or resource bundle that does not exist.

java.lang.IllegalStateException 
java.lang.UnsupportedOperationException -  Attempting to run an invalid operation in collections and concurrency.

-------- EXAM TRICK ---------------
 Remember to pay attention that throw and throws aren’t reversed in the code that you see on the exam. 
 
It is illegal to declare a subclass exception in a catch block that is lower down in the list than a superclass
exception because it will be unreachable code.

Java will not allow you to declare a catch block for a checked exception type that cannot potentially be thrown by the try clause body.
--------- USING MULTI-CATCH  -------------------------------- 
catch(Exception1 e | Exception2 e | Exception3 e) // DOES NOT COMPILE
catch(Exception1 e1 | Exception2 e2 | Exception3 e3) // DOES NOT COMPILE
catch(Exception1 | Exception2 | Exception3 e)

La variabile dell'errore deve essere specificata una volta sola.

 catch (FileNotFoundException | IOException e) { } // DOES NOT COMPILE
 Perche  FileNotFoundException  è una sottoclasse di  IOException
 
catch(RuntimeException e) {
 e = new RuntimeException();   // non è un errore nel catch normale ma nel multi-catch il codice non compilA.
}

------------------ TRY-WITH-RESOURCES --------------------

try (BufferedReader r = Files.newBufferedReader(path1);
 BufferedWriter w = Files.newBufferedWriter(path2)) {
 // protected code
}
Le risporse specidicate nel try verranno chiuse automaticamente alla fine.



try (BufferedReader r = Files.newBufferedReader(path1);
 BufferedWriter w = Files.newBufferedWriter(path2)) {
 //protected code
} catch (IOException e) {
 // exeption handler
} finally {
 // finally block
}

Posso aggiungere anche nel TRY-WITH-RESOURCES un catch e un finally ma sono opzionali.
Nei miei catch e finally opzionali le risorse saranno gia chiuse.

Nel try non posso inserire cosa voglio io ma solo classi che implementano l'interfaccia java.lang.AutoCloseable implementando il metodo:
public void close() throws Exception;
Avendo l'interfaccia dichiarato direttamente Exception allora io quando l'implemento posso implementare qualsiasi sottoclasse di Exception. 


Ricordarti che le checked exception vanno gestite quindi se io scrivo una classe che implementa AutoCloseable e implemento una variante di 
close() che fa thrown di una checked exception come Exception allora in qualche modo nel TRY-WITH-RESOURCES sono obbligato a gestirla.


--------------- SUPPRESSED EXCEPTIONS ---------------
public class JammedTurkeyCage implements AutoCloseable {
   public void close() throws IllegalStateException {
       throw new IllegalStateException("Cage door does not close");
    } 
    
Quindi ho il mio AutoClosable JAMMEDTURKEYCAGE che mi lancia una UncheckedException

15: try (JammedTurkeyCage t = new JammedTurkeyCage()) {
16:     throw new IllegalStateException("turkeys ran off");
17: } catch (IllegalStateException e) {
18:     System.out.println("caught: " + e.getMessage());
19:     for (Throwable t: e.getSuppressed())
20:          System.out.println(t.getMessage());
21: }
Allora Quella che viene lanciata per prima è quella alla riga 16 e viene chiamata primary exception. Dopo aver lanciato quella 
java chiude la connessione ma chiamando close() lancia una seconda eccezzione oramai chiamata  suppressed exception. 
Output: 
caught: turkeys ran off
Cage door does not close

-----------
22: try (JammedTurkeyCage t = new JammedTurkeyCage()) {
23:     throw new RuntimeException("turkeys ran off");
24: } catch (IllegalStateException e) {
25:     System.out.println("caught: " + e.getMessage());
26: }
Se faccio cosi invcece la mia eccezzione della riga 23 non viene catchata e se ne occupera il metodo prima che mi stamperà entrambe.

27: try (JammedTurkeyCage t1 = new JammedTurkeyCage();
28:     JammedTurkeyCage t2 = new JammedTurkeyCage()) {
29:           System.out.println("turkeys entered cages");
30: } catch (IllegalStateException e) {
31:     System.out.println("caught: " + e.getMessage());
32:     for (Throwable t: e.getSuppressed())
33:           System.out.println(t.getMessage());
34: }
On line 29, the turkeys enter the cages without exception. Then Java tries to close both cages automatically. t2 is closed first, since Java closes resources in the reverse order from
which it created them. This throws an exception. Since it is the first exception to occur, it becomes the primary exception. Then t1 is closed. Since an exception has already been
thrown, this one becomes a suppressed exception. The output is

turkeys entered cages
caught: Cage door does not close
Cage door does not close


Infine se alla fine di tutto dentro un finally lancio ancora un ezccezione predo tutte le altre perche java fa schifo. 


-------------------- ASSERTIONS ---------------------------------
An assertion is a Boolean expression that you place at a point in your code where you expect something to be true. 

Syntax:  assert boolean_expression;     assert boolean_expression: error_message;
If assertions are enabled and the boolean expression is false , then our assertion is invalid and a java.lang.AssertionError is thrown.

By default, assert statements are ignored by the JVM at runtime. To enable assertions, use
the -enableassertions or -ea flag on the command line    

1 java -ea:com.wiley.demos... my.programs.Main
The three dots means any class in the specifi ed package or subpackages. You can also enable assertions for a specific class:
2 java -ea:com.wiley.demos.TestColors my.programs.Main

You can disable assertions using the -disableassertions (or -da ) fl ag for a specific class or package that was previously enabled. 

ex:  java -ea:com.wiley.demos... -da:com.wiley.demos.TestColors my.programs.Main 

Attento all'esame al codice che presenta assertion ma non è enabled perche in quel caso java le ignora.

########################################################################################### CAPITOLO 7 ##############################################################################################

I system threads sono in generale i thread della JVM tipo il Garbage Collector ha un suo thread. Quando si dice che noi non dovremmo mai 
chatchare Errors è perche vengono lanciati dai system threads e per esempio anche se fossimo in OOM e venisse lanciato un Error e noi lo 
catchassimo non servirebbe a nulla perche non potremmo fare molto senza memoria. 

Alternatively, a user-defined thread is one created by the application developer to accomplish a specific task.

A CONTEXT SWITCH is the process of storing a thread’s current state and later restoring the state of the thread to continue execution

Finally, a thread can interrupt or supersede another thread if it has a higher thread priority than the other thread. A thread priority is a numeric value associated with a thread
that is taken into consideration by the thread scheduler when determining which threads should currently be executing.

Thread.MIN_PRIORITY 1
Thread.NORM_PRIORITY 5
Thread.MAX_PRIORITY 10


----------  RUNNABLE --------------
@FunctionalInterface public interface Runnable {
    void run();
}
------------- THREAD ---------------

Remember that order of thread execution is not often guaranteed. The exam commonly presents questions in which multiple tasks are started at
the same time, and you must determine the result. 
Abbiamo due modi per usare i threads: 

1. Implementaimo Runnable e chiamiamo il metodo .start() che farà partire il Thread che eseguirà il corpo del metodo run()
public class PrintData implements Runnable {
   public void run() {
      for(int i=0; i<3; i++)
      System.out.println("Printing record: "+i); 
   }
   public static void main(String[] args) {
      (new Thread(new PrintData())).start();   //fa partire il nuovo thread
   }
}

2. Estendiamo la classe thread e sovrascriviamo il metodo run, poi chiamiamo start() che creerà un nuovo thread che eseguirà il corpo di run()
public class ReadInventoryThread extends Thread {
    public void run() {
       System.out.println("Printing zoo inventory");
    }
    public static void main(String[] args) {
       (new ReadInventoryThread()).start();
    }
}

Poi li chiamo cosi:
public static void main(String[] args) {
   System.out.println("begin");
   (new ReadInventoryThread()).start();
   (new Thread(new PrintData())).start();
   (new ReadInventoryThread()).start();
 }  
All'esame stai attento che i vari .start() vengano chiamati perche è possibile che ti freghino non chimandoli ma chiamando 
i .run() non creando cosi dei thread ma delle esecuzioni del codice sequenziali. 

Thread.sleep(1000); // 1 SECOND     it may throw A InterruptedException!!

---------------------------- EXECUTORSERVICE ---------------------------

----------------------SINGLE-THREAD EXECUTOR --------------------
Since EXECUTORSERVICE is an interface. The Concurrency API includes the Executors factory class that can be used to create instances
of the ExecutorService object.
ExecutorService service = Executors.newSingleThreadExecutor();

La logica la inseriamo dentro un try catch. Dove nel try innizializziamo in nostro ExecutorService service e eseguiamo azioni
diverse su questo singolo thread traimite il metodo .execute()  
   service.execute(() -> System.out.println("Printing zoo inventory"));
nel finally: 
   if(service != null) service.shutdown();

--------------------Shutting Down a Thread Executor------------------
Once you have finished using a thread executor, it is important that you call the shutdown() method. A thread executor creates a non-daemon thread on the first task that
is executed, so failing to call shutdown() will result in your application never terminating.

Quando creo un executor il suo stato è  ATTIVO 
- Accepts New Tasks
- Executes Tasks
- isShutdown() = false
- isTerminated() = false

Quando chiamo il metodo shutdown() il suo stato è SHUTTING DOWN
- Rejects New Tasks
- Executes Tasks
- isShutdown() = true
- isTerminated() = false
Qui l'executor non inizia altri task ma quelli che ha iniziato li porta a termine.

Quando tutti i task sono finiti il suop stato è 
- Rejects New Tasks (Throwing a  RejectedExecutionException)
- No Tasks Running
- isShutdown() = true
- isTerminated() = true
For the exam, you should be aware that shutdown() does not actually stop any tasks that have already been submitted to the thread executor. 
 
The ExecutorService provides a method called shutdownNow(), which attempts to stop all running tasks and discards any that have not been started yet.
Note that shutdownNow() attempts to stop all running tasks. 

---------------  SUBMITTING TASKS  ---------------------------
The EXECUTE() method takes a Runnable lambda expression or instance and completes the task asynchronously. 

1 void execute(Runnable command) 
Executes a Runnable task at some point in the future
2 Future<?> submit(Runnable task) 
Executes a Runnable task at some point in the future and returns a Future representing the task
3 <T> Future<T> submit(Callable<T> task) 
Executes a Callable task at some point in the future and returns a Future representing the pending results of the task
4 <T> List<Future<T>> invokeAll( Collection<? extends Callable<T>> tasks) throws InterruptedException
Executes the given tasks, synchronously returning the results of all tasks as a Collection of Future objects, in the same order they were in the original collection
5 <T> T invokeAny( Collection<? extends Callable<T>> tasks) throws InterruptedException, ExecutionException
Executes the given tasks, synchronously returning the result of one of finished tasks,cancelling any unfinished tasks

------------ SUBMITTING TASK COLLECTIONS  -------------------------
 invokeAll() and invokeAny()
Both of these methods take a Collection object containing a list of tasks to execute.

The invokeAll() method executes all tasks in a provided collection and returns a List of ordered Future objects, with one Future object corresponding to each submitted task,
in the order they were in the original collection. Even though Future.isDone() returns true for each element in the returned List,
a task could have completed normally or thrown an exception.

The invokeAny() method executes a collection of tasks and returns the result of one of the tasks that successfully completes execution, cancelling all unfinished tasks. 
While the first task to finish is often returned, this behavior is not guaranteed, as any completed task can be returned by this method.

Finally, the invokeAll() method will wait indefinitely until all tasks are complete, while the invokeAny() method will wait indefinitely until at least one task completes.

------------- FUTURE --------------------------------------------
Future<?> future = service.submit(() -> System.out.println("Hello Zoo"));

1. boolean isDone()
Returns true if the task was completed, threw an exception, or was cancelled.

2. boolean isCancelled() 
Returns true if the task was cancelled before it completely normally.

3. boolean cancel() 
Attempts to cancel execution of the task.

4. V get() 
Retrieves the result of a task, waiting endlessly if it is not yet available.

V get(long timeout, TimeUnit unit)
Retrieves the result of a task, waiting the specified amount of time. If the result is not ready by the time the timeout is reached, a checked TimeoutException will be thrown.


-----------------  CALLABLE   ----------------------

@FunctionalInterface public interface Callable<V> {
 	V call() throws Exception;
}

1: service.submit(() -> {Thread.sleep(1000); return null;});
2: service.submit(() -> {Thread.sleep(1000);});  //not compile

Thread.sleep() lancia una checked exception InterruptedException. Nella chimata 1 ilcodice compila poiche essendo una Callable call permette le eccezioni. 
La chiamata 2 essendo interpretata come un runnable non avendo il tipo di ritorno non compila perche run non accetta eccezioni.
 
Since Callable supports a return type when used with ExecutorService, it is often preferred over Runnable when using the Concurrency API.

Future<Integer> result = service.submit(() -> 30+11); // è un callable perche ha un ritorno e posso leggerlo
System.out.println(result.get());

---------------- WAITING FOR ALL TASKS TO FINISH ------------------
First, we shut down the thread executor using the shutdown() method. Next, we use the awaitTermination(long timeout, TimeUnit unit).

if(service != null) {
    service.awaitTermination(1, TimeUnit.MINUTES);
    // Check whether all tasks are finished
    if(service.isTerminated())
       System.out.println("All tasks finished");
}

------------- SCHEDULING TASKS ---------------------------------------

ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();

Note that we could implicitly cast an instance of ScheduledExecutorService to ExecutorService, although doing so would remove access to the scheduled methods that we want to use.
Questo perche ScheduledExecutorService è una sottointerfaccia di ExecutorService.

1 schedule(Callable<V> callable,long delay, TimeUnit unit)    ritorna un  ScheduledFuture<V> 
Creates and executes a Callable task after the given delay

2. schedule(Runnable command,long delay, TimeUnit unit)  ritorna un  ScheduledFuture<V> 
Creates and executes a Runnable task after the given delay

3. scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)
Creates and executes a Runnable task after the given initial delay, creating a new task every period value that passes.

4. scheduleAtFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)
Creates and executes a Runnable task after the given initial delay and subsequently with the given delay between the termination of one execution and the commencement of the next.


ScheduledFuture<V> is identical to the Future<V> class, except that it includes a getDelay() method that returns the delay set when the process was created. 

 ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
 Runnable task1 = () -> System.out.println("Hello Zoo");
 Callable<String> task2 = () -> "Monkey";
 Future<?> result1 = service.schedule(task1, 10, TimeUnit.SECONDS);
 Future<?> result2 = service.schedule(task2, 8, TimeUnit.MINUTES); 
 
service.scheduleAtFixedRate(command,5,1,TimeUnit.MINUTE);   //se il mio runnable command ci mette sempre piu di 5 minuti creero una lista infinita di task.
service.scheduleAtFixedDelay(command,0,2,TimeUnit.MINUTE); 


-----------------  INCREASING CONCURRENCY WITH POOLS ----------------------------
A thread pool is a group of pre-instantiated reusable threads that are available to perform a set of arbitrary tasks.

1 newSingleThreadExecutor() --> ExecutorService 
Creates a single-threaded executor that uses a single worker thread operating off an unbounded queue. Results are processed sequentially in the order in which they are submitted.

2 newSingleThreadScheduledExecutor() -->  Scheduled ExecutorService
Creates a single-threaded executor that can schedule commands to run after a given delay or to execute periodically.

3 newCachedThreadPool() --> ExecutorService 
Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available.
L'uso di questo è sconsigliato per thread le cui esecuzuini impiegano molto tempo perche potrebbe crearne troppi nel tempo. 

4 newFixedThreadPool(int nThreads) --> ExecutorService 
Creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.

5 newScheduledThreadPool(int nThreads) --> Scheduled ExecutorService
Creates a thread pool that can schedule commands to run after a given delay or to execute periodically.


ex: 
ScheduledExecutorService service = Executors.newScheduledThreadPool(10);
service.scheduleAtFixedRate(command,3,1,TimeUnit.MINUTE);

Whereas with a single-thread executor and a five-minute task execution time, an endless set of tasks would be scheduled over time. With a pooled executor, this can be avoided. If
the pool size is sufficiently large, 10 for example, then as each thread finishes, it is returned to the pool and results in new threads available for the next tasks as they come up.

----------------------------------------------------SYNCHRONIZING DATA ACCESS -------------------------------------------------
AtomicBoolean        A boolean value that may be updated atomically
AtomicInteger        An int value that may be updated atomically
AtomicIntegerArray   An int array in which elements may be updated atomically
AtomicLong           A long value that may be updated atomically
AtomicLongArray      A long array in which elements may be updated atomically
AtomicReference      A generic object reference that may be updated atomically
AtomicReferenceArray An array of generic object references in which elements may beupdated atomically

Classi dove la lettura del valore e la modifica del valore è un unica azione atomica  e finche io non ho finito di scrivere il valore quall'altro non puo nemmeno leggerlo.
Su queste classi dovrò operare con dei metodi eccone alcuni da conoscere: 
1 get() Retrieve the current value
2 set() Set the given value, equivalent to the assignment = operator
3 getAndSet() Atomically sets the new value and returns the old value
4 incrementAndGet() For numeric classes, atomic pre-increment operation equivalent to ++value
5 getAndIncrement() For numeric classes, atomic post-increment operation equivalent to value++
6 decrementAndGet() For numeric classes, atomic pre-decrement operation equivalent to --value
7 getAndDecrement() For numeric classes, atomic post-decrement operation equivalent to value--


public class SheepManager {
    //private int sheepCount = 0;
    private AtomicInteger sheepCount = new AtomicInteger(0); 
    private void incrementAndReport() {
       // System.out.print((++sheepCount)+" ");
       System.out.print(sheepCount.incrementAndGet()+" "); 
    }
    public static void main(String[] args) {
        ExecutorService service = null;
        try {
            service = Executors.newFixedThreadPool(20);
            SheepManager manager = new SheepManager();
            for(int i=0; i<10; i++)
               service.submit(() -> manager.incrementAndReport());
        } finally {
            if(service != null) service.shutdown();
        }
    }
}
Vediamo cosi che avremo printatti tutti i numeri da 1 a 10 , mentre nel caso di prima era possibile avere 10 numeri da 1 a 8 con due 1. Questo perche due thread leggevano contemporanemante 0
aggiornavano contemporaneamente a 1 e stampavano entrambi 1. 

Solo che ora l'azione di incremento e lettura è atomica. Ma l'azione di stampa no, quindi potrebbe stampare prima il 2 e poi 1. Perche il thread che stampa 2 potrebbe essere avvantaggiato dallo scheduler in
qualche modo per qualche strano motivo. 

------------SYNCHRONIZED----------------------

private void incrementAndReport() {
    synchronized(this) {
        System.out.print((++sheepCount)+" ");
    }
 }
Con synchronized risolvo senza nemmeno usare AtomicInteger. 
In questo modo sto dichiarando this come monitor. 
Ogni thread che entra in quella parte di codice deve controllare il monitor se un altro thread ha il lock su quel monitor allora il nuovo thread deve aspettare che quello finisca e liberi il monitor.

Possiamo usare anche questa sintassi 
 private synchronized void incrementAndReport() {
     System.out.print((++sheepCount)+" ");
 } 
Che introduce il modifier synchronized che rende sincronizzato il metodo e l'oggetto su cui andrà a sincronizzare rendendolo un monitor è automaticamente this. 

Possiamo aggiungere il modifier synchronized anche metodi statici , in quel caso l'oggetto usato come monitor non è l'istanza della classe essendo un metoto statico ma l'oggetto classe in se. 
esempio:
1:
public static void printDaysWork() {
    synchronized(SheepManager.class) {
        System.out.print("Finished work");
    }
}
2:
public static synchronized void printDaysWork() {
    System.out.print("Finished work");
}

---------------------------------- USING CONCURRENT COLLECTIONS -----------------------
public class ZooManager {
    private Map<String,Object> foodData = new ConcurrentHashMap<String,Object>();  // in questo esempio è bastato solo questo

    public void put(String key, String value) {
       foodData.put(key, value);
    }
    public Object get(String key) {
       return foodData.get(key);
    }
}


When two threads try to modify the same non-concurrent collection, the JVM may throw a ConcurrentModificationException at runtime.
Puo succedere anche con un solo thread 
Map<String, Object> foodData = new HashMap<String, Object>();
foodData.put("penguin", 1);
foodData.put("flamingo", 2);
for(String key: foodData.keySet()){ foodData.remove(key);}
Questo codice lancia ConcurrentModificationException perche foodData.heySet() al secondo giro non è aggiornato con il nuovo stato di foodData. 
Per risolverlo basta inizializzare foodData come un  ConcurrentHashMap<String, Object>();

If all of the threads are accessing an established immutable or read-only collection, a concurrent collection class is not required


                                                             Eements Ordered? Sorted? Blocking?
1 ConcurrentHashMap  -  ConcurrentMap                           No No No
2 ConcurrentLinkedDeque - Deque                                 Yes No No
3 ConcurrentLinkedQueue - Queue                                 Yes No No
4 ConcurrentSkipListMap - ConcurrentMap SortedMap NavigableMap  Yes Yes No
5 ConcurrentSkipListSet - SortedSet NavigableSet                Yes Yes No
6 CopyOnWriteArrayList - List                                   Yes No No
7 CopyOnWriteArraySet - Set                                     No No No
8 LinkedBlockingDeque - BlockingQueue BlockingDeque             Yes No Yes
9 LinkedBlockingQueue - BlockingQueue                           Yes No Yes

in it.cla.test.alvolo.dequeTest ci sono dei esempi dei 2 e 3. 

8 e 9 
 LINKEDBLOCKINGQUEUE and LINKEDBLOCKINGDEQUE. The BlockingQueue is just like a regular Queue, except that it includes methods that will wait a specific amount of time to complete an operation
 
-------- BLOCKINGQUEUE WAITING METHODS -------------
 - offer(E e, long timeout, TimeUnit unit)
Adds item to the queue waiting the specified time, returning false if time elapses before space is available
 - poll(long timeout, TimeUnit unit)
Retrieves and removes an item from the queue, waiting the specified time, returning null if the time elapses before the item is available.

NB can each throw a checked InterruptedException.  Attento è un trucco durante l'esame usarli senza specificare l'eccezione.

try {
    BlockingQueue<Integer> blockingQueue = new LinkedBlockingQueue<>();
    blockingQueue.offer(39);
    blockingQueue.offer(3, 4, TimeUnit.SECONDS);
    System.out.println(blockingQueue.poll());
    System.out.println(blockingQueue.poll(10, TimeUnit.MILLISECONDS));
} catch (InterruptedException e) {
 // Handle interruption
}
---------BLOCKINGDEQUEUE WAITING METHODS -------------
- offerFirst(E e, long timeout, TimeUnit unit)
Adds an item to the front of the queue, waiting a specified time, returning false if time elapses before space is available
- offerLast(E e, long timeout, TimeUnit unit)
Adds an item to the tail of the queue, waiting a specified time, returning false if time elapses before space is available
- pollFirst(long timeout, TimeUnit unit)
Retrieves and removes an item from the front of the queue, waiting the specified time, returning null if the time elapses before the item is available
- pollLast(long timeout, TimeUnit unit)
Retrieves and removes an item from the tail of the queue, waiting the specified time, returning null if the time elapses before the item is available

NB can each throw a checked InterruptedException. 
Since BlockingDeque extends Queue, Deque, and BlockingQueue, anche i metodi citati sopra di semplic poll e offer funzionano sulla deque. 

------------------- SKIPLIST COLLECTIONS --------------------

The SkipList classes, ConcurrentSkipListSet and ConcurrentSkipListMap, are concurrent versions of their sorted counterparts, TreeSet and TreeMap, respectively.
When you see SkipList or SkipSet on the exam, just think “sorted” concurrent collections and the rest should follow naturally.
Like other queue examples, it is recommended that you assign these objects to interface references, such as SortedMap or NavigableSet.

------------------- COPYONWRITE COLLECTIONS ------------------
Quando modifico in qualsiasi modo queste collection java mi crea una copia della collection con le modifiche invece di modificare direttamente la collection.
Cosi se qualcuno stava iterando la collection in quel momento le mie modifiche non gli procureranno un errore.

List<Integer> list = new CopyOnWriteArrayList<>(Arrays.asList(4,3,52));  
    for(Integer item: list) {
        System.out.print(item+" ");
        list.add(9);
    }
System.out.println();
System.out.println("Size: "+list.size());

 4 3 52
 Size: 6 
Se la lista non fosse stato di tipo CopyOnWriteArrayList avrei avuto un ConcurrentModificationException.


----------------------OBTAINING SYNCHRONIZED COLLECTIONS ----------------
the Concurrency API also includes methods for obtaining synchronized versions of existing non-concurrent collection objects
synchronizedCollection(Collection<T> c)
synchronizedList(List<T> list)
synchronizedMap(Map<K,V> m)
synchronizedNavigableMap(NavigableMap<K,V> m)
synchronizedNavigableSet(NavigableSet<T> s)
synchronizedSet(Set<T> s)
synchronizedSortedMap(SortedMap<K,V> m)
synchronizedSortedSet(SortedSet<T> s)

While this methods synchronize access to the data elements, such as the get() and set() methods, they do not synchronize access on any iterators that you
may create from the synchronized collection. Therefore, it is imperative that you use a synchronization block if you need to iterate over any of the returned collections.

-------------------------------- PARALLEL STREAM -------------------------------
- parallel()
The first way to create a parallel stream is from an existing stream. You just call parallel() on an existing stream to convert it to one that supports multi-threaded
processing, as shown in the following code:
 Stream<Integer> stream = Arrays.asList(1,2,3,4,5,6).stream();
 Stream<Integer> parallelStream = stream.parallel();

Be aware that parallel() is an intermediate operation that operates on the original stream. 
- parallelStream()
Il secondo modo è chiamare parallelStream su una Collection 
 Stream<Integer> parallelStream2 = Arrays.asList(1,2,3,4,5,6).parallelStream();
 	
 	
	Arrays.asList(1,2,3,4,5,6)
	 .parallelStream()
	 .forEach(s -> System.out.print(s+" "));  //4 1 6 5 2 3
	 
	Arrays.asList(1,2,3,4,5,6)
	 .parallelStream()
	 .forEachOrdered(s -> System.out.print(s+" ")); //1 2 3 4 5 6
Naturalmente con il secondo modo perdi un po di performance. 

------------------------------ PARALLEL REDUCTIONS -------------------------------------
System.out.print(Arrays.asList(1,2,3,4,5,6).parallelStream().findAny().get());

The result is that the output could be 4, 1, or really any value in the stream. You can see that with parallel streams, the results of findAny() are no longer predictable.
Questo perche la JVM fa partire piu thread ma ti ritorna il risultato del primo che finisce, e non è detto che il primo a finire sia quello che elabora il valore 1.

Any stream operation that is based on order, including findFirst(), limit(), or skip(), may actually perform more slowly in a parallel environment. This is a result of a
parallel processing task being forced to coordinate all of its threads in a synchronized-like fashion.
On the plus side, the results of ordered operations on a parallel stream will be consistent with a serial stream. For example, calling skip(5).limit(2).findFirst() will return the
same result on ordered serial and parallel streams.
Quindi effettuando operazioni basate sull'ordine come findFirst(), limit(), or skip() il risultato è esseere lo stesso dello stream()



----------------- COMBINING RESULTS WITH REDUCE() ---------------------------
System.out.println(Arrays.asList('w', 'o', 'l', 'f')
 .stream()
 .reduce("",(c,s1) -> c + s1,
 (s2,s3) -> s2 + s3)); 
 
 The naming of the variables in this stream example is not accidental. The variable c is interpreted as a char , whereas s1 , s2 , and s3 are String
values. Recall that in the three-argument version of reduce() , the accumulator is a BiFunction , while the combiner is BinaryOperator .

 On parallel streams, the reduce() method works by applying the reduction to pairs of elements within the stream to create intermediate values and then combining those 
 intermediate values to produce a final result.  
 
 
  Requirements for reduce() Arguments
 ■ The identity must be defined such that for all elements in the stream u , combiner.apply(identity, u) is equal to u .
 ■ The accumulator operator op must be associative and stateless such that (a op b) op c is equal to a op (b op c) .
 ■ The combiner operator must also be associative and stateless and compatible with the identity, such that for all u and t combiner.apply(u,accumulator.apply(identity,t)) is equal to accumulator.apply(u,t) .
 
 If you follow these principles when building your reduce() arguments, then the operations can be performed using a parallel stream and the results will be ordered as they
would be with a serial stream. Note that these principles still apply to the identity and accumulator when using the one- or two-argument version of reduce() on parallel streams.
 
 System.out.println(Arrays.asList("w","o","l","f")
 .parallelStream()
 .reduce("X",String::concat));
In fact, it can output XwXoXlXf. 
infatti non segue il primo requirement. 


------------------- COMBING RESULTS WITH COLLECT() --------------------------
Like reduce(), the Streams API includes a three-argument version of collect() that takes accumulator and combiner operators, along with a supplier operator instead of an identity.

Stream<String> stream = Stream.of("w", "o", "l", "f").parallel();
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o] 

Requirements for Parallel Reduction with collect()
■ The stream is parallel.
■ The parameter of the collect operation has the Collector.Characteristics.CONCURRENT characteristic.
■ Either the stream is unordered, or the collector has the characteristic Collector.Characteristics.UNORDERED.

While Collectors. toSet() does have the UNORDERED characteristic, it does not have the CONCURRENT characteristic; therefore the previous collector example will not be 
performed as a concurrent reduction.

Collectors.toConcurrentMap() 
Collectors.groupingByConcurrent()

Stream<String> ohMy = Stream.of("lions", "tigers", "bears").parallel();
ConcurrentMap<Integer, String> map = ohMy.collect(
 Collectors.toConcurrentMap(String::length, k -> k, (s1, s2) -> s1 + "," + s2));
System.out.println(map); // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // java.util.concurrent.ConcurrentHashMap

Stream<String> ohMy = Stream.of("lions", "tigers", "bears").parallel();
ConcurrentMap<Integer, List<String>> map = ohMy.collect(
 Collectors.groupingByConcurrent(String::length));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}

-------------------- CYCLICBARRIER   -------------------
The CyclicBarrier takes in its constructors a limit value, indicating the number of threads to wait for.
As each thread finishes, it calls the await()on the cyclic barrier. Once the specified number of threads have called await(), the barrier is released and all threads can continue.

Basta creare un istanza:
CyclicBarrier c1 = new CyclicBarrier(4);

passarla al thread 
service.submit(() -> manager.performTask(c1,c2));

public int await() throws InterruptedException,  BrokenBarrierException

nella sua logica il thread fa robe poi si mette in attesa degli altri prima di andare avanti 
removeAnimals();
 c1.await();
 cleanPen();

 ---------------------- FORK/JOIN FRAMEWORK -----------------
 Si basa sul scrivere una classe che estende RecursiveAction o RecursiveTask (both of which implement the ForkJoinTask interface)
 ENtreambe sono classi astratte che mi obbligano a definire un metodo: 
  RecursiveAction:  void compute() 
  RecursiveTask: T compute()
 Qurste classi nel loro compure si baso sulla recursione per reistanziare altri oggetti e tramite i parametri del costruttori distriibuire meno lavaro ai thread. 
 
Esempio metodo compute di una classe che estende      ----RECURSIVEACTION.----- 
  
protected void compute() {
 	if(end-start <= 3)
 		for(int i=start; i<end; i++) {
 			weights[i] = (double)new Random().nextInt(100);
			System.out.println("Animal Weighed: "+i);
    	}
 	else {
 		int middle = start+((end-start)/2);
 		System.out.println("[start="+start+",middle="+middle+",end="+end+"]");
 		invokeAll(new WeighAnimalAction(weights,start,middle),
 			      new WeighAnimalAction(weights,middle,end));
 	}
}

Qui se la classe viene istanziata con dei parametrila cui differenza è maggiore di 3 allora vengono istanziate altre due classi dello stesso tipo 
e il lavoro viene suddiviso a loro tramite invokeAll.

La classe e il metodo compute vengono fatti partire cosi 

ForkJoinTask<?> task = new WeighAnimalAction(weights,0,weights.length);
ForkJoinPool pool pool = new ForkJoinPool();
pool.invoke(task);

La stessa classe di prima ora estende                 ----- RECURSIVETASK -----------
il compute avrà ora un tipo di ritorno
public class WeighAnimalTask extends RecursiveTask<Double> 


protected Double compute() {
	if(end-start <= 3) {
		double sum = 0;
		for(int i=start; i<end; i++) {
			weights[i] = (double)new Random().nextInt(100);
			System.out.println("Animal Weighed: "+i);
			sum += weights[i];
		}
		return sum;  //vediamo che ora ha un tipo di ritorno
	} else {
		int middle = start+((end-start)/2);
		System.out.println("[start="+start+",middle="+middle+",end="+end+"]");
		RecursiveTask<Double> otherTask = new WeighAnimalTask(weights,start,middle);
		otherTask.fork(); //faccio partire un ramo 
		return new WeighAnimalTask(weights,middle,end).compute() + otherTask.join(); //torno la somma dei due sottorami della ricorsione.
 	}
}

While our base case is mostly unchanged, except for returning a sum value, the recursive case is quite different. Since the invokeAll() method doesn’t return a value, we instead
issue a fork() and join() command to retrieve the recursive data. The fork() method instructs the fork/join framework to complete the task in a separate thread, while the
join() method causes the current thread to wait for the results.

e lo chiamo cosi:
 ForkJoinTask<Double> task = new WeighAnimalTask(weights,0,weights.length);
 ForkJoinPool pool pool = new ForkJoinPool();
 Double sum = pool.invoke(task);
 System.out.println("Sum: "+sum);

 RecursiveTask<Double> otherTask = new WeighAnimalTask(weights,start,middle);
 Double otherResult = otherTask.fork().join();
 return new WeighAnimalTask(weights,middle,end).compute() + otherResult;

In this example, the current thread calls join(), causing it to wait for the [start,middle] subtask to finish before starting on the [middle,end] subtask. In this manner, the results are
actually performed in a single-threaded manner. For the exam, make sure that fork() is called before the current thread begins a subtask and that join() is called after it finishes
retrieving the results, in order for them to be done in parallel.


-------------- TIPS FOR REVIEWING A FORK/JOIN CLASS ----------------
■ The class should extend RecursiveAction or RecursiveTask.
■ If the class extends RecursiveAction, then it should override a protected compute() method that takes no arguments and returns void. 
■ If the class extends RecursiveTask, then it should override a protected compute() method that takes no arguments and returns a generic type listed in the class definition.
■ The invokeAll() method takes two instances of the fork/join class and does not return a result.
■ The fork() method causes a new task to be submitted to the pool and is similar to the thread executor submit() method.
■ The join() method is called after the fork() method and causes the current thread to wait for the results of a subtask.
■ Unlike fork(), calling compute() within a compute() method causes the task to wait for the results of the subtask.
■ The fork() method should be called before the current thread performs a compute() operation, with join() called to read the results afterward.
■ Since compute() takes no arguments, the constructor of the class is often used to pass instructions to the task.

-----------------   LIVENESS    ----------------------------------------
Liveness problems, then, are those in which the application becomes unresponsive or in some kind of “stuck” state. For the exam, there are three types of liveness issues with
which you should be familiar: deadlock, starvation, and livelock.

----------------------- DEADLOCK   -------------------------------------
Deadlock occurs when two or more threads are blocked forever, each waiting on the other. 
----------------------- STARVATION   -------------------------------------
Starvation occurs when a single thread is perpetually denied access to a shared resource or lock.
----------------------- LIVELOCK   -------------------------------------
Livelock occurs when two or more threads are conceptually blocked forever, although they are each still active and trying to complete their task. Livelock is a special case of resource
starvation in which two or more threads actively try to acquire a set of locks, are unable to do so, and restart part of the process.

----------------------------RACE CONDITIONS --------------------------------------------------
Si manifesta quando due thread cercano di fare la stessa cosa contemporanemente.  In generale permetterlo ad entrambi è la cosa peggiore e porta a invalid data.
Respringere entrambi è ok. Far passare solo uno e bloccare l'altro è perfetto. Monitor e lock con syncrhonized is the way. 

For the exam, you should understand that race conditions lead to invalid data if they are not properly handled. Even the solution where both participants fail to proceed is preferable
to one in which invalid data is permitted to enter the system. 
