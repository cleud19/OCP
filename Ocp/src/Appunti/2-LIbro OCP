Appunti Libro OCP 

DOMANDE INIZIALI  Suoerate in File Apppostito 

############################## CAPITOLO 1 ##########################################

OVVERRIDE
Quando utilizziamo la @override stiamo dicendo al compilatore che abbiamo l'intenzione di fare override di un metodo 
se per caso il metodo è scritto male e invece di un override stiamo facendo un overloading di un metodo allora 
il codice NON COMPILA 
stai attento all'esame che quando c'è una @override stiamo veramente facendo override cosi da trovare errori di compilazione

ENUM
Season s1 = Season.valueOf("SUMMER"); // SUMMER
Season s2 = Season.valueOf("summer"); // exception
uun enum puo essere instanziata anche da una stringa ma deve essere esatta

 The constructor is private because it can only be called from within the enum .
The code will not compile with a public constructor. 

interfaces require public methods. 

############################## CAPITOLO 2 ##########################################
Una functional interface è una interfaccia con un solo metodo abstract quindi se ce ne sono altri di tipo
default oppure static la nostra interfaccia rimane functional.
LAMBDA
() -> new Duck()   //ci vanno le parentesi poiche non ci sono parametri
d -> {return d.quack();}
(Duck d) -> d.quack()  //le parentesi ci vanno poiche specificato il tipo
(Animal a, Duck d) -> d.quack()   //le parentesi vanno messe poiche i parametri sono2

. When using {} in the body of the
lambda expression, you must use the return statement if the functional interface method
that lambda implements returns a value. Alternatively, a return statement is optional when
the return type of the method is void.

a, b -> a.startsWith("test") // DOES NOT COMPILE
c -> return 10; // DOES NOT COMPILE
a -> { return a.startsWith("test") } // DOES NOT COMPILE

(a, b) -> a.startsWith("test")  //esempi coretti rispetto a quelli su
c -> { return 10; }
a -> { return a.startsWith("test"); }

(int y, z) -> {int x=1; return y+10; } // DOES NOT COMPILE   una volta specificato il tipo di un parametro devo specificarla di tutti
(a, b) -> { int a = 0; return 5;} // DOES NOT COMPILE non si puo assegnare un nuovo calore ad un parametro

CASTING 
public class Bird {}
public class Fish {
 public static void main(String[] args) {
 Fish fish = new Fish();
 Bird bird = (Fish)bird; // DOES NOT COMPILE
 }
}

non si puo fare il cast di due oggetti che non sono relazionati tra di loro in nessun modo , non compila
INMUTYABILE CLASS

1.per settare le proprieta usa sempre il costruttore, se una delle proprieta è u oggetto copialo instanziane uno uguale 
ma non asegnare il parametro dato al costruttore direttamente alla tua proprietà o dall'esterno chi ti ha passato il 
parametro avrà ancora un puntatore al oggetto che corrisponde alla tua proprietà

 2. Mark all of the instance variables private and final .
 3. Don’t define any setter methods.
 4. Don’t allow referenced mutable objects to be modified or accessed directly.
 5. Prevent methods from being overridden. Cioe metti la classe come final 
 
 
 ############################## CAPITOLO 3 ##########################################
 CPOLLECTIONS
 
        String[] array = { "gerbil", "mouse" };      // [gerbil, mouse] 
  5:    List<String> list = Arrays.asList(array);    // returns fixed size list 
  6:    list.set(1, "test");                         // [gerbil, test] 
  7:    array[0] = "new";                            // [new, test] 
  8:    String[] array2 = (String[]) list.toArray(); // [new, test] 
  9:    list.remove(1);                              // throws UnsupportedOperationException 
 //  line 9 shows that list is not resizable because it is backed by the underlying array.
 
 le due liste rimangono collegate!!  
 ------------------------------------------------------------------
 ci sono due versioni
 list.remove(int index)
 list.remove(Object obj)
 --------------------------------------------------------------------
 GENERICS 
 
 Generics nei metodi va prima dichiarato il tipo
 3:    public static <T> void sink(T t) { } 
 4:    public static <T> T identity(T t) { return t; } 
 5:    public static T noGood(T t) { return t; }  // DOES NOT COMPILE 
 
 Line 3 shows the formal parameter type immediately before the return type of void. 
 Line 4 shows the return type being the formal parameter type. It looks weird, but it is correct. Line 5 omits the formal parameter type, 
 and therefore it does not compile.
 
  quando chiami un metodo che è stato dichiarato con un formal parameter type esiste anche la sintassi in cui dichiari esplicitamente che tipo di oggetto 
  gli stai passando  --->   Box.<String>ship("package");
  anche se non c'è bisogno di dicgiararlo in modo cosi esplicito bisogna sapere dell'esistenza anche di questa sintassi.  
 -----------------------------------------------
 
 in generale quando si usano dei generics java istanzia tutto a runtime come se fosse un object la cosa che fa automaticamente 
 è aggiungerti dei cast che tu non vedi per operare con i vari tipi di classi che sostituiamo ai nostri generics. Questo per sopperire al fatto che prima non esistevano 
 e quindi per mantenere il codice legacy valido anche i generics a runtime sono dei object come prima solo che vengono aggiunti dei casting automatici. 
 In generale java ora se lavori con una classe senza generics ti avvisa con un warning per dirti di stare attento
 
  1:	public class LegacyUnicorns { 
  2:       public static void main(String[] args) { 
  3:          java.util.List<Unicorn> unicorns = new java.util.ArrayList<>(); 
  4:          addUnicorn(unicorns); 
  5:          Unicorn unicorn = unicorns.get(0);    // ClassCastException 
  6:       } 
  7:       private static void addUnicorn(List unicorn) { 
  8:          unicorn.add(new Dragon()); 
  9:       } } 
  
  come puoi vedere l'errore non avviene alla riga 8 perche cmq lui sotto lavora con dei objects l'errore avviene alla riga 5 quando si aspetta si prendere un 
  oggetto unicrn quindi efettua automaticamente un cast andando in errore
  
  1:    public class LegacyAutoboxing { 
  2:       public static void main(String[] args) { 
  3:          java.util.List numbers = new java.util.ArrayList(); 
  4:          numbers.add(5); 
  5:          int result = numbers.get(0);    // DOES NOT COMPILE 
  6:       } 
  7:   }
  Qui vediamo che a riga 5 funziona perche java autoboxes in modo automatico l'int in Integer
  Alla riga 6 però non usando i generics non sa che nella lista c'è un Integer e un Object non puo essere unboxed in un int quindi non compila!
 ------------------------------------------------
 Technically, you can
remove elements from the list, but the exam won't ask about this.
2: static class Sparrow extends Bird { }
3: static class Bird { }
4:
5: public static void main(String[] args) {
6: List<? extends Bird> birds = new ArrayList<Bird>();
7: birds.add(new Sparrow()); // DOES NOT COMPILE
8: birds.add(new Bird()); // DOES NOT COMPILE
9: }


The problem stems from the fact that Java doesn’t know what type List<? extends
Bird> really is. It could be List<Bird> or List<Sparrow> or some other generic type that
hasn’t even been written yet. Line 7 doesn’t compile because we can’t add a Sparrow to
List<Bird>, and line 8 doesn’t compile because we can’t add a Bird to List<Sparrow>.
From Java’s point of view, both scenarios are equally possible so neither is allowed.
 
 
VARIE 
String s1 = "Canada"; String s2 = new String(s1); 
s1 points to the string pool 
s2 points to an object on the heap, since it is created at runtime