Appunti Libro OCP 

DOMANDE INIZIALI  Suoerate in File Apppostito 

############################## CAPITOLO 1 ##########################################

OVVERRIDE
Quando utilizziamo la @override stiamo dicendo al compilatore che abbiamo l'intenzione di fare override di un metodo 
se per caso il metodo è scritto male e invece di un override stiamo facendo un overloading di un metodo allora 
il codice NON COMPILA 
stai attento all'esame che quando c'è una @override stiamo veramente facendo override cosi da trovare errori di compilazione

ENUM
Season s1 = Season.valueOf("SUMMER"); // SUMMER
Season s2 = Season.valueOf("summer"); // exception
uun enum puo essere instanziata anche da una stringa ma deve essere esatta

 The constructor is private because it can only be called from within the enum .
The code will not compile with a public constructor. 

interfaces require public methods. 

############################## CAPITOLO 2 ##########################################
Una functional interface è una interfaccia con un solo metodo abstract quindi se ce ne sono altri di tipo
default oppure static la nostra interfaccia rimane functional.
LAMBDA
() -> new Duck()   //ci vanno le parentesi poiche non ci sono parametri
d -> {return d.quack();}
(Duck d) -> d.quack()  //le parentesi ci vanno poiche specificato il tipo
(Animal a, Duck d) -> d.quack()   //le parentesi vanno messe poiche i parametri sono2

. When using {} in the body of the
lambda expression, you must use the return statement if the functional interface method
that lambda implements returns a value. Alternatively, a return statement is optional when
the return type of the method is void.

a, b -> a.startsWith("test") // DOES NOT COMPILE
c -> return 10; // DOES NOT COMPILE
a -> { return a.startsWith("test") } // DOES NOT COMPILE

(a, b) -> a.startsWith("test")  //esempi coretti rispetto a quelli su
c -> { return 10; }
a -> { return a.startsWith("test"); }

(int y, z) -> {int x=1; return y+10; } // DOES NOT COMPILE   una volta specificato il tipo di un parametro devo specificarla di tutti
(a, b) -> { int a = 0; return 5;} // DOES NOT COMPILE non si puo assegnare un nuovo calore ad un parametro

CASTING 
public class Bird {}
public class Fish {
 public static void main(String[] args) {
 Fish fish = new Fish();
 Bird bird = (Fish)bird; // DOES NOT COMPILE
 }
}

non si puo fare il cast di due oggetti che non sono relazionati tra di loro in nessun modo , non compila
INMUTYABILE CLASS

1.per settare le proprieta usa sempre il costruttore, se una delle proprieta è u oggetto copialo instanziane uno uguale 
ma non asegnare il parametro dato al costruttore direttamente alla tua proprietà o dall'esterno chi ti ha passato il 
parametro avrà ancora un puntatore al oggetto che corrisponde alla tua proprietà

 2. Mark all of the instance variables private and final .
 3. Don’t define any setter methods.
 4. Don’t allow referenced mutable objects to be modified or accessed directly.
 5. Prevent methods from being overridden. Cioe metti la classe come final 
 
 
 ############################## CAPITOLO 3 ##########################################
 CPOLLECTIONS
 
        String[] array = { "gerbil", "mouse" };      // [gerbil, mouse] 
  5:    List<String> list = Arrays.asList(array);    // returns fixed size list 
  6:    list.set(1, "test");                         // [gerbil, test] 
  7:    array[0] = "new";                            // [new, test] 
  8:    String[] array2 = (String[]) list.toArray(); // [new, test] 
  9:    list.remove(1);                              // throws UnsupportedOperationException 
 //  line 9 shows that list is not resizable because it is backed by the underlying array.
 
 le due liste rimangono collegate!!  
 ----------------------------------------------------------------------------------------------------------------
 ci sono due versioni
 list.remove(int index)
 list.remove(Object obj)
 
 queue nn ha la rimozione per index ma solo per oggetto
 -------------------------------------------------------------------------------------------------------------------------
 GENERICS 
 
 Generics nei metodi va prima dichiarato il tipo
 3:    public static <T> void sink(T t) { } 
 4:    public static <T> T identity(T t) { return t; } 
 5:    public static T noGood(T t) { return t; }  // DOES NOT COMPILE 
 
 Line 3 shows the formal parameter type immediately before the return type of void. 
 Line 4 shows the return type being the formal parameter type. It looks weird, but it is correct. Line 5 omits the formal parameter type, 
 and therefore it does not compile.
 
  quando chiami un metodo che è stato dichiarato con un formal parameter type esiste anche la sintassi in cui dichiari esplicitamente che tipo di oggetto 
  gli stai passando  --->   Box.<String>ship("package");
  anche se non c'è bisogno di dicgiararlo in modo cosi esplicito bisogna sapere dell'esistenza anche di questa sintassi.  
 ------------------------------------------------------------------------------------------------------------------------------
 
 in generale quando si usano dei generics java istanzia tutto a runtime come se fosse un object la cosa che fa automaticamente 
 è aggiungerti dei cast che tu non vedi per operare con i vari tipi di classi che sostituiamo ai nostri generics. Questo per sopperire al fatto che prima non esistevano 
 e quindi per mantenere il codice legacy valido anche i generics a runtime sono dei object come prima solo che vengono aggiunti dei casting automatici. 
 In generale java ora se lavori con una classe senza generics ti avvisa con un warning per dirti di stare attento
 
  1:	public class LegacyUnicorns { 
  2:       public static void main(String[] args) { 
  3:          java.util.List<Unicorn> unicorns = new java.util.ArrayList<>(); 
  4:          addUnicorn(unicorns); 
  5:          Unicorn unicorn = unicorns.get(0);    // ClassCastException 
  6:       } 
  7:       private static void addUnicorn(List unicorn) { 
  8:          unicorn.add(new Dragon()); 
  9:       } } 
  
  come puoi vedere l'errore non avviene alla riga 8 perche cmq lui sotto lavora con dei objects l'errore avviene alla riga 5 quando si aspetta si prendere un 
  oggetto unicrn quindi efettua automaticamente un cast andando in errore
  
  1:    public class LegacyAutoboxing { 
  2:       public static void main(String[] args) { 
  3:          java.util.List numbers = new java.util.ArrayList(); 
  4:          numbers.add(5); 
  5:          int result = numbers.get(0);    // DOES NOT COMPILE 
  6:       } 
  7:   }
  Qui vediamo che a riga 5 funziona perche java autoboxes in modo automatico l'int in Integer
  Alla riga 6 però non usando i generics non sa che nella lista c'è un Integer e un Object non puo essere unboxed in un int quindi non compila!
 --------------------------------------------------------------------------------------------------------------------------------
 Technically, you can
remove elements from the list, but the exam won't ask about this.
2: static class Sparrow extends Bird { }
3: static class Bird { }
4:
5: public static void main(String[] args) {
6: List<? extends Bird> birds = new ArrayList<Bird>();
7: birds.add(new Sparrow()); // DOES NOT COMPILE
8: birds.add(new Bird()); // DOES NOT COMPILE
9: }


The problem stems from the fact that Java doesn’t know what type List<? extends
Bird> really is. It could be List<Bird> or List<Sparrow> or some other generic type that
hasn’t even been written yet. Line 7 doesn’t compile because we can’t add a Sparrow to
List<Bird>, and line 8 doesn’t compile because we can’t add a Bird to List<Sparrow>.
From Java’s point of view, both scenarios are equally possible so neither is allowed.
 ------------------------------------------------------------------------------------------------------------------------------------------
 GENERICS-
 
class A {}
class B extends A { }
class C extends B { }

 <B extends A> B method3(List<B> list) {
 return new B(); // DOES NOT COMPILE
}

Io dichiaro B nel metodo come tipo di parametro generico che estende A. Ma ho anche una classe che si chiama B sopra
ora nello scope del mio metodo B sarà questo parametro generico che estende A e quindi potrà essere  A,B o C.
Quindi essendo un parametro generico non posso istanziarne un nuovo oggetto , non conoscendo che oggetto sia ne che costruttore abbia. 
--------------------------------------------------------------------------------------------------------------------------------------
GENERICS e WILDCARD

<X> void method5(List<X super B> list) { // DOES NOT COMPILE
}
scoppia perche cerco di mischiare la sintassi della wildcard con quella dei generics. Li ci va una ? e non una X: 

---------------------------------------------------------------------------------------------------------------------------------------------
NAVIGABLE  SET 
 
E lower(E e) Returns greatest element that is < e, or null if no such element
E floor(E e) Returns greatest element that is <= e, or null if no such element
E ceiling(E e) Returns smallest element that is >= e, or null if no such element
E higher(E e) Returns smallest element that is > e, or null if no such element

---------------------------------------------------------------------------------------------------------------------------------------------
QUEUE 

ArrayDeque e LinkedList sono due esempi di Queue

AGGIUNTA
- boolean offer(E e){}  Aggiunge e torna true o null 
- boolean add(E e){}   Aggiunge e torna true o eccezione

RIMOZIONE
- E poll(E e){}  Rimuove e torna prossimo elemento oppure null se vuota 
- E remove(E e){}  Rimuove e torna prossimo elemento o eccezione se vuota


ISPEZIONE

- E peek(E e){}   Ritorna il primo elemento della queue null se fosse vuota 
- E element(E e){}   Ritorna il primo elemento della queue eccexxione se fosse vuota 
 
 
 offer/poll/peek  QUEUE senza eccezzioni 
 push/poll/peek  STACK SENZA eccezioni
 
 QUEUE
  12:   Queue<Integer> queue = new ArrayDeque<>(); 
  13:   System.out.println(queue.offer(10));  // true    10
  14:   System.out.println(queue.offer(4));   // true    10|4
  15:   System.out.println(queue.peek());     // 10 	 10|4
  16:   System.out.println(queue.poll());     // 10 	 4
  17:   System.out.println(queue.poll());     // 4        
  18:   System.out.println(queue.peek());     // null 
 STACK
  12:   ArrayDeque<Integer> stack = new ArrayDeque<>(); 
  13:   stack.push(10); 								 10
  14:   stack.push(4); 									 4|10
  15:   System.out.println(stack.peek());     // 4 		 4|10
  16:   System.out.println(stack.poll());     // 4 	     10
  17:   System.out.println(stack.poll());     // 10 
  18:   System.out.println(stack.peek());     // null
 
-----------------------------------------------------------------------------------------------------------------------
COLLECTION

System.out.println(map.contains("lion")); // DOES NOT COMPILE
System.out.println(map.containsKey("lion")); // true

In generale certe collection accettano i valori null e altre no.
Partendo logicamente le prime che non dovrebbero accettare valori null sono le collection ordinate, poiche non 
ha senso comparare "casa" con null. 

This means that TreeSet cannot contain null elements. 
It also means that TreeMap cannot contain null keys. Null values are OK.
 
Un altra collection in cui non piu aggiungere null è ArrayDeque. 
Questo perche se fai poll() per vedere se la collection è vuota ed è vuota ti torna null. ora noi se l'elemento 
null ce lo mettiamo non sappiamo piu se la queue è vuota o meno quindi java non lo permette.

Remember that numbers sort before letters and uppercase letters sort
before lowercase letters. 

-------------------------------------------------------------------------------------------------------------------------
COMPARABLE
Difference 						Comparable	     Comparator
Package name 					java.lang 	     java.util

Interface must be
implemented by class 	 		   Yes 		        No
comparing? 

Method name in interface 		compareTo 	     compare
Number of parameters 				1				 2
Common to declare using a lambda    No 			    Yes

Durante l'esame verranno spesso cambiate per farti sbagliare

Se istanzio un TreeSet di oggetti che non implementano comparable allora la prima volta ache andrò ad aggingerli al mio TreeSet 
Verrà lanciata un eccezione (ClassCastìException). Perche a RunTime essendo TreeSet ordinata secondo l'ordine naturale dei oggetti si accorge che 
il mio oggetto non implementa comparable e va in errore. 

Quando istanzio un TreeSet nel costruttore posso passargli un Comparator da usare per ordinare gli oggetti:
--------------------------------------------------------------------------------------------------------------------------

REFERENCE TO METHODS
14: Consumer<List<Integer>> methodRef1 = Collections::sort;
15: Consumer<List<Integer>> lambda1 = l -> Collections.sort(l); 

REFERENCE ISTANCE METHOD ON A SPECIFIC INSTANCE:
String str = "abc";
17: Predicate<String> methodRef2 = str::startsWith;
18: Predicate<String> lambda2 = s -> str.startsWith(s); 

SEMPRE ISTANCE METHOD ma senza conoscerlo in anticipo
19: Predicate<String> methodRef3 = String::isEmpty;   
20: Predicate<String> lambda3 = s -> s.isEmpty();
//infatti isEmpty non è un metodo statico quindi non è che lo chiamo dalla classe

CONSTRUCTOR REFERENCE 
21: Supplier<ArrayList> methodRef4 = ArrayList::new;
22: Supplier<ArrayList> lambda4 = () -> new ArrayList();

--------------------------------------------------------------------------------------------------------------------------------------
.MERGE() on COLLECTION
Funzione che modifica il valore di una chiave in una mappa o aggiunge una chiave con un valore nuovo in base ai casi 

La logica con cui lo fa viene descritta dentro una BiFunction.

11: BiFunction<String, String, String> mapper = (v1, v2)
12: -> v1.length() > v2.length() ? v1: v2;
13:
14: Map<String, String> favorites = new HashMap<>();
15: favorites.put("Jenny", "Bus Tour");
16: favorites.put("Tom", "Tram");
17:
18: String jenny = favorites.merge("Jenny", "Skyride", mapper);
19: String tom = favorites.merge("Tom", "Skyride", mapper);
20:
21: System.out.println(favorites); // {Tom=Skyride, Jenny=Bus Tour}
22: System.out.println(jenny); // Bus Tour
23: System.out.println(tom); // Skyride

Quindi la funzione .merge() applica la BiFunction applicando come parametri il secondo parametro della funzione merge e la value della key rappresentata
dal primo parametro di merge. 

Da ricordare che se la key è null il merge con il corpo della bifunction non viene applicato ma viene direttamente inserito il nuovo campo 

 ESEMPIO 2
 
BiFunction<String, String, String> mapper = (v1, v2) -> null;
Map<String, String> favorites = new HashMap<>();
favorites.put("Jenny", "Bus Tour");
favorites.put("Tom", "Bus Tour");
favorites.merge("Jenny", "Skyride", mapper);
favorites.merge("Sam", "Skyride", mapper);  //verrà aggiunto senza eseguire il mapper perche chiave non trovata
System.out.println(favorites); // {Tom=Bus Tour, Sam=Skyride}

=======

SE il ritorno del merge è null allora viene rimossa la chiave
computeIfPresent non si compota come merge se la chiave non la trova nella mappa non aggiunge il valore.

-------------------------------------

ricordati che le mappe non hanno il metodo .contains() 
ma il containsValue() e containsKey()


 ############################## CAPITOLO 4 ##########################################
 USARE VARIABILI NEI LAMBDA 
 Lambda expressions can access 
 static variables, 
 instance variables, 
 effectively final method parameters,
 and effectively final local variables.
-------------------------------------------------------------------

INTERFACCIA        PARAMETRI   RETURN TYPE   METHOD
Supplier<T>		       0           T         get
Consumer<T> 	       1 (T)       void      accept
BiConsumer<T, U> 	   2 (T, U)    void      accept
Predicate<T>    	   1 (T)       boolean   test
BiPredicate<T, U> 	   2 (T, U)    boolean   test
Function<T, R>  	   1 (T)       R         apply
BiFunction<T, U, R>	   2 (T, U)    R         apply
UnaryOperator<T>       1 (T)       T         apply
BinaryOperator<T>      2 (T, T)    T         apply

--------------------------------------------------------------------

 STREAMS
  1 Stream<String> s = Stream.of("brown bear-", "grizzly-");
  2 s.sorted(Comparator.reverseOrder()).forEach(System.out::print); // grizzly-brown bear-
 
  3 s.sorted(Comparator::reverseOrder); // DOES NOT COMPILE 
 
 Alla riga 2 va perche il sorted ha bisogno di un Comparator<T> e il comparator è un interfaccia funzionale che ha un metodo
 int compare(T,T); Ora nella riga due utilizzo il metodo statico dell'interfaccia Comparator per tornare un oggetto Comparator 
 cioe per tornare un implementazione del mio metodo compare.
 
 Alla riga 3 sto effettuando un method reference , cioe cerco di assegnare al metodo compare(T,T) che vuole il mio sort
 il metodo Comparator<T> reverseOrder() andando cosi in errore. 
 
 
 TERMINAL OPERATIONS 
 1.   count()         -   long count()
 	The count() method determines the number of elements in a finite stream. For an infinite
 	stream, it hangs. 
 
 2.   min() and max() -   Optional<T> min(<? super T> comparator)
	The min() and max() methods allow you to pass a custom comparator and find the smallest or largest value in a finite stream according to that sort order. Like count(), min() and
	max() hang on an infinite stream because they cannot be sure that a smaller or larger value
	isn’t coming later in the stream. 
	
	Stream<String> s = Stream.of("monkey", "ape", "bonobo");
	Optional<String> min = s.min((s1, s2) -> s1.length()—s2.length());
	min.ifPresent(System.out::println); // ape  
 
 3.   findAny() and findFirst()    -  Optional<T> findAny()
	The findAny() and findFirst() methods return an element of the stream unless the stream
	is empty. If the stream is empty, they return an empty Optional. This is the first method
	you’ve seen that works with an infinite stream. Since Java generates only the amount of
	stream you need, the infinite stream needs to generate only one element.
	
	Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
	Stream<String> infinite = Stream.generate(() -> "chimp");
	s.findAny().ifPresent(System.out::println); // monkey
	infinite.findAny().ifPresent(System.out::println); // chimp
	
4.    allMatch() , anyMatch() and noneMatch()   -  boolean anyMatch(Predicate <? super T> predicate) 
	The allMatch() , anyMatch() and noneMatch() methods search a stream and return information about how the stream pertains to the predicate. These may or may not terminate
	for infi nite streams. It depends on the data. Like the fi nd methods, they are not reductions
	because they do not necessarily look at all of the elements. 
	
	 List<String> list = Arrays.asList("monkey", "2", "chimp");
	 Stream<String> infinite = Stream.generate(() -> "chimp");
	 Predicate<String> pred = x -> Character.isLetter(x.charAt(0));
	 System.out.println(list.stream().anyMatch(pred)); // true
	 System.out.println(list.stream().allMatch(pred)); // false
	 System.out.println(list.stream().noneMatch(pred)); // false
	 System.out.println(infinite.anyMatch(pred)); // true 
		
5.   forEach()    - void forEach(Consumer<? super T> action) 
	A looping construct is available. As expected, calling forEach() on an infinite stream does
	not terminate. Since there is no return value, it is not a reduction. 
	While forEach() sounds like a loop, it is really a terminal operator for streams. 
	
	 Stream<String> s = Stream.of("Monkey", "Gorilla", "Bonobo");
 	 s.forEach(System.out::print); // MonkeyGorillaBonobo 
 	 
6.     reduce()    -       T reduce(T identity, BinaryOperator<T> accumulator) 

	 The reduce() method combines a stream into a single object. As you can tell from the
	 name, it is a reduction
	 
	  Stream<String> stream = Stream.of("w", "o", "l", "f");
	  String word = stream.reduce("", (s, c) -> s + c);
	  System.out.println(word); // wolf 
	  
	 Posso anche non specificare l'identity ma non essendo sicuro che ci sia un valore di ritorno in questo caso 
	 viene restituito un oggetto Optional.
	 
	 BinaryOperator<Integer> op = (a, b) -> a * b;
	 Stream<Integer> empty = Stream.empty();
	 Stream<Integer> oneElement = Stream.of(3);
	 Stream<Integer> threeElements = Stream.of(3, 5, 6);
	 
	 empty.reduce(op).ifPresent(System.out::print); // no output
	 oneElement.reduce(op).ifPresent(System.out::print); // 3
	 threeElements.reduce(op).ifPresent(System.out::print); // 90
	 
7.   collect()    -      <R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner)
	The collect() method is a special type of reduction called a mutable reduction. It is
	more efficient than a regular reduction because we use the same mutable object while 
	accumulating. Common mutable objects include StringBuilder and ArrayList. 
	
	Stream<String> stream = Stream.of("w", "o", "l", "f");
	TreeSet<String> set = stream.collect(TreeSet::new, TreeSet::add,
	TreeSet::addAll);
	System.out.println(set); // [f, l, o, w]
	
	The collector has three parts as before. The supplier creates an empty TreeSet. The
	accumulator adds a single String from the Stream to the TreeSet. The combiner adds all
	of the elements of one TreeSet to another in case the operations were done in parallel and
	need to be merged. 
	
	La classe Collectors implementa molti tipi diversi di collectors che devi conoscere. Abbiamo visto prima la notazione piu lunga perche ci servirà nelkl'esame per 
	creare i nostri propri collectors. 
	
	Stream<String> stream = Stream.of("w", "o", "l", "f");
 	TreeSet<String> set = stream.collect(Collectors.toCollection(TreeSet::new));
 	System.out.println(set); // [f, l, o, w] 
	
 USING COMMON INTERMEDIATE OPERATIONS 
 
 1.   filter()   -    Stream<T> filter(Predicate<? super T> predicate) 
 	 Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
	 s.filter(x -> x.startsWith("m")).forEach(System.out::print); // monkey 
 
 2.  distinct()   -      Stream<T> distinct() 
     The distinct() method returns a stream with duplicate values removed
     
	 Stream<String> s = Stream.of("duck", "duck", "duck", "goose");
     s.distinct().forEach(System.out::print); // duckgoose 
     
 3. limit() and skip()   -   Stream<T> limit(int maxSize)  -    Stream<T> skip(int n) 
	The limit() and skip() methods make a Stream smaller. 
    
    Stream<Integer> s = Stream.iterate(1, n -> n + 1);
    s.skip(5).limit(2).forEach(System.out::print); // 67 
    
 4.  map()   -    <R> Stream<R> map(<? super T, ? extends R> mapper) 
    The map() method creates a one-to-one mapping from the elements in the stream to the elements of the next step in the stream.
    
	Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
 	s.map(String::length).forEach(System.out::print); // 676 
 	
 5. flatMap()    irrilevante troppo complessa la signature
	The flatMap() method takes each element in the stream and makes any elements it contains top-level elements in a single stream. This is helpful when you want to remove empty
	elements from a stream or you want to combine a stream of lists. 
	
	Quindi se ho una lista di liste , flatMap mi fa uno strem di elementi unici. 
	La differenza con map è che map associa ad ogni elemento un solo elemento nel nuovo stream. 
	FlatMap ad ogni elemento associa da 0 a n elementi nello stream risultante. 
	
	List<String> zero = Arrays.asList();
	List<String> one = Arrays.asList("Bonobo");
	List<String> two = Arrays.asList("Mama Gorilla", "Baby Gorilla");
	Stream<List<String>> animals = Stream.of(zero, one, two);
	animals.flatMap(l -> l.stream()).forEach(System.out::println);
	
	Bonobo
	Mama Gorilla
	Baby Gorilla

6.   sorted()   -    Stream<T> sorted() -   Stream<T> sorted(Comparator<? super T> comparator)
	The sorted() method returns a stream with the elements sorted. Just like sorting arrays,
	Java uses natural ordering unless we specify a comparator. The method signatures are

7.  peek()   -     Stream<T> peek(Consumer<? super T> action)   
    It is useful for debugging because it
	allows us to perform a stream operation without actually changing the stream. 
	
	 Stream<String> stream = Stream.of("black bear", "brown bear", "grizzly");
	 long count = stream.filter(s -> s.startsWith("g"))
	 .peek(System.out::println).count(); // grizzly 
		
---------------------------------------------------


25: List<String> cats = new ArrayList<>();
26: cats.add("Annie");
27: cats.add("Ripley");
28: Stream<String> stream = cats.stream();
29: cats.add("KC");
30: System.out.println(stream.count());
// stampa 3 

Vediamo che i streams sono lazily evaluated e quindi alla riga 28 lo stream non è veramente instaziato 
ma viene creato un oggetto che sa dove guardare quando verrà chiamato lo stream. 
Lo stream viene interpellato a riga 30 ed è solo allora che verra instanziato. 
------------------------------------------------------------
TOMAP
Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, String> map = ohMy.collect(Collectors.toMap(
String::length, k -> k, (s1, s2) -> s1 + "," + s2, TreeMap::new));
System.out.println(map); // // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // class. java.util.TreeMap

Qui con (s1, s2) -> s1 + "," + s2 specifico cosa fare nel caso di due chiavi identiche senza questo andrebbe in errore. 
Sotto con il groupingBy ho una funzione che lo fa apposta. 

GROUPINGBY

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, Set<String>> map = ohMy.collect(
 Collectors.groupingBy(String::length, TreeMap::new, Collectors.toSet()));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}

PARTITIONINGBY
Il partitioning divide sempre per due gruppi true e false

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Boolean, Set<String>> map = ohMy.collect(
Collectors.partitioningBy(s -> s.length() <= 7, Collectors.toSet()));
System.out.println(map);// {false=[], true=[lions, tigers, bears]}

MAPPING
Il mapping ci fa specificare ancora un sottolivello di collect

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Optional<Character>> map = ohMy.collect(
 groupingBy(
 String::length,
 Collectors.mapping(s -> s.charAt(0),
 minBy(Comparator.naturalOrder()))));
System.out.println(map); // {5=Optional[b], 6=Optional[t]}

--------------------------------------
Recognize which operations cause a stream pipeline to execute. Intermediate operations
do not run until the terminal operation is encountered. If no terminal operation is in the
pipeline, a Stream is returned but not executed. Examples of terminal operations include
collect(), forEach(), min(), and reduce().

-----------------------------------------------------------------------------------------
The average() method returns an OptionalDouble since averages of any type can
result in a fraction.
-----------------------------------------------------------------------------------------



VARIE 
String s1 = "Canada"; String s2 = new String(s1); 
s1 points to the string pool 
s2 points to an object on the heap, since it is created at runtime