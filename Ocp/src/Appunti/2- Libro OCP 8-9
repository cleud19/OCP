########################################################################################### CAPITOLO 8 ##############################################################################################
----------------------------------------- FILE --------------------------------------------
The File class is used to read information about existing files and directories, list the contents of a directory, and create/delete files and directories.
The File class cannot read or write data within a file, although it can be passed as a reference to many stream classes to read or write data.

The ABSOLUTE PATH of a file or directory is the full path from the root directory to the file or directory, including all subdirectories that contain the file or directory.
Alternatively, the relative path of a file or directory is the path from the current working directory to file or directory.

/home/smith/data/zoo.txt    ABSOLUTE PATH
 
The following is a relative path to the same file, assuming the users current directory was set to /home/smith.

data/zoo.txt                RELATIVE PATH
Unixbased systems use  / for paths, whereas Windows-based systems use the backslash \ character. 
Java offers two options to retrieve the local separator character: 
a system property and a static variable defined in the File class. 

public class FileSample {
	public static void main(String[] args) {
	File file = new File("/home/smith/data/zoo.txt");
	System.out.println(file.exists());
    } 
}

File parent = new File("/home/smith");
File child = new File(parent,"data/zoo.txt");   // se parent e' null java lo ignora e utilizza solo il secondo
e' equivalente  quello di prima.

------------------ COMMONLY USED JAVA.IO.FILE METHODS -------------------------------------------------
1 exists() Returns true if the file or directory exists.
2 getName() Returns the name of the file or directory denoted by this path.
3 getAbsolutePath() Returns the absolute pathname string of this path.
4 isDirectory() Returns true if the file denoted by this path is a directory.
5 isFile() Returns true if the file denoted by this path is a file.
6 length() Returns the number of bytes in the file. For performance reasons, the file system may allocate more bytes on disk than the file actually uses.
7 lastModified() Returns the number of milliseconds since the epoch when the file was last modified.
8 delete() Deletes the file or directory. If this pathname denotes a directory, then the directory must be empty in order to be deleted.
9 renameTo(File) Renames the file denoted by this path.
10 mkdir() Creates the directory named by this path.
11 mkdirs() Creates the directory named by this path including any nonexistent parent directories.
12 getParent() Returns the abstract pathname of this abstract pathnames parent or null if this pathname does not name a parent directory.
13 listFiles() Returns a File[] array denoting the files in the directory.

To move a file using java.io.File, you should use the renameTo() method, since
there are no move() or mv() methods.
----------------- INTRODUCING STREAMS ----------------------------------------------------------------------
Note that the I/O streams that we discuss in this chapter are data streams and completely unrelated to the new Stream API that you saw.

a STRAM is a list of data elements presented sequentially. Each type of stream segments data  into a “wave” or “block” in a particular way.
Nearly all are built on top of reading or writing an individual byte or an array of bytes at a time. The reasoning behind more high-order streams is for convenience as well as performance.

---------------------------- BYTE STREAMS VS. CHARACTER STREAMS ----------------------------------------------
Fra i vari Stram noteremo quelli che nel nome hnano STREAM e quelli che hanno READER/WRITER, ecco le differenze:
1. The stream classes are used for inputting and outputting all types of binary or byte data.
2. The reader and writer classes are used for inputting and outputting only character and String data.
It is important to remember that even though readers/writers do not contain the word Stream in their class name, they are still in fact streams!

The java.io API is structured such that all of the stream classes have the word InputStream or OutputStream in their name, while all Reader/Writer classes have either Reader or Writer in their name.
Attento ai nomi dei vari Stream ti aiuteranno a capirne la logica senza conoscerli necessariamente. 

Tutte le classi che Di solito hanno InputStreamQualcosa hano anche OutputStreamQualcosa quindi anche le ReaderQualcosa avranno uun WriterQualcosa. 
A questa regola fanno ecezione: 
1 PrintWriter has no accompanying PrintReader class. 
2 PrintStream class has no corresponding InputStream class.



try (
 BufferedReader bufferedReader = new BufferedReader(
 new FileReader("zoo-data.txt"))) {
 System.out.println(bufferedReader.readLine());
}

In this example, FileReader is the low-level stream reader, whereas BufferedReader is the high-level stream that takes a FileReader as input. Many operations on the high-level stream
pass through as operations to the underlying low-level stream, such as read() or close().
Other operations override or add new functionality to the low-level stream methods. The highlevel stream adds new methods, such as readLine(), as well as performance enhancements for
reading and filtering the low-level data. 

try (ObjectInputStream objectStream = new ObjectInputStream(
 new BufferedInputStream(
 new FileInputStream("zoo-data.txt")))) {
 System.out.println(objectStream.readObject());
}

Buffered classes read or write data in groups, rather than a single byte or character at a time.
 ------------------------------ STREAM BASE CLASSES --------------------------------------------------------------------------
 Classi Astratte:  InputStream, OutputStream, Reader, and Writer
 Per convenienza java ha mantenuto il nome di queste classi nelle sottoclassi come suffisso. For example, ObjectInputStream ends with InputStream, meaning it has InputStream as an inherited parent class.
 Most stream classes in java.io follow this pattern, PrintStream, which is an OutputStream, does not.
 
new BufferedInputStream(new FileReader("zoo-data.txt")); // DOES NOT COMPILE
new BufferedWriter(new FileOutputStream("zoo-data.txt")); // DOES NOT COMPILE
new ObjectInputStream(new FileOutputStream("zoo-data.txt")); // DOES NOT COMPILE
new BufferedInputStream(new InputStream()); // DOES NOT COMPILE Perche InputStream Ã¨ una classe abstract. 
Attento all'esame cercheranno di fregarti combinando tipi diversi di classi non compatibili.



â–  A class with the word InputStream or OutputStream in its name is used for reading or writing binary data, respectively.
â–  A class with the word Reader or Writer in its name is used for reading or writing character or string data, respectively.
â–  Most, but not all, input classes have a corresponding output class.
â–  A low-level stream connects directly with the source of the data.
â–  A high-level stream is built on top of another stream using wrapping.
â–  A class with Buffered in its name reads or writes data in groups of bytes or characters and often improves performance in sequential file systems.



Class Name        Low/High   Level Description
InputStream         N/A      The abstract class all InputStream classes inherit from
OutputStream        N/A      The abstract class all OutputStream classes inherit from
Reader              N/A      The abstract class all Reader classes inherit from
Writer              N/A      The abstract class all Writer classes inherit from
FileInputStream     Low      Reads file data as bytes
FileOutputStream    Low      Writes file data as bytes
FileReader          Low      Reads file data as characters
FileWriter          Low      Writes file data as characters
BufferedReader      High     Reads character data from an existing Reader in a buffered manner, which improves efficiency and performance
BufferedWriter      High     Writes character data to an existing Writer in a buffered manner, which improves efficiency and performance
ObjectInputStream   High     Deserializes primitive Java data types and graphs of Java objects from an existing InputStream
ObjectOutputStream  High     Serializes primitive Java data types and graphs of Java objects to an existing OutputStream
InputStreamReader   High     Reads character data from an existing InputStream
OutputStreamWriter  High     Writes character data to an existing OutputStream
PrintStream         High     Writes formatted representations of Java objects to a binary stream
PrintWriter         High     Writes formatted representations of Java objects to a text-based output stream


----------------CLOSING THE STREAM --------------------------------
Since streams are considered resources, it is imperative that they be closed after they are used lest they lead to resource leaks.

----------------FLUSHING THE STREAM ---------------------------------
Quando scriviamo dei dati su un OutputStream questo non vuol dire che i dati vengono direttamente scritti sul file. Spesso vengono salvati in una memoria di chace (cambia in base al SO). 
E se il sistema termina in modo inaspettato quello che avevamo scritto sull'ouputStream non arriva mai al file perche rimarrà  nella cache.
To address this, Java provides a flush() method, which requests that all accumulated data be written immediately to disk.  Unless the data that you are writing
is extremely critical, the flush() method should only be used intermittently.
----------------MARKING THE STREAM ----------------------------------

Chiamare markSupported() sullo stream per vedere se torna true e quindi vedere se è supportato meno il mark.
mark(int) delimiti per quanti bytes vuoi mantenere il sengo.Quando vuoi tornare indietro chiami  reset() e torni a dove hai messo il segno.In pratica da dove metti il mark quei dati li metti in memoria
cosi da poterli leggere di nuovo una volta chimato reset()
InputStream is = ...
System.out.print ((char)is.read()); A
if(is.markSupported()) {
	is.mark(100);
	System.out.print((char)is.read()); B
	System.out.print((char)is.read()); C
	is.reset();
}
System.out.print((char)is.read()); B
System.out.print((char)is.read()); C
System.out.print((char)is.read()); D

------------------SKIPPING OVER DATA-------------------------------
The InputStream and Reader classes also include a skip(long) method, which as you might expect skips over a certain number of bytes. It returns a long value, which indicates
the number of bytes that were actually skipped. 

InputStream is = ...  (TIGERS)
System.out.print ((char)is.read()); T
is.skip(2) IG 
is.read();  E  //vediamo che in questo caso un read non gestito è come lo skip solo che è lento sempre meglio lo skip per molti byte
System.out.print((char)is.read()); R
System.out.print((char)is.read()); S

-------------------------THE FILEINPUTSTREAM AND FILEOUTPUTSTREAM CLASSES------------------------------------
They are used to read bytes from a file or write bytes to a file, respectively. These classes include constructors that take a File object or String, representing a path to the file.
The data in a FileInputStream object is commonly accessed by successive calls to the read() method until a value of -1 is returned, indicating that the end of the stream.
The FileInputStream class also contains overloaded versions of the read() method, which take a pointer to a byte array where the data is written. The method returns an
integer value indicating how many bytes can be read into the byte array. It is also used by Buffered classes to improve performance.
A FileOutputStream object is accessed by writing successive bytes using the write(int) method. Like the FileInputStream class, the FileOutputStream also contains overloaded
versions of the write() method that allow a byte array to be passed and can be used by Buffered classes.  

try (InputStream in = new FileInputStream(source);    
	 OutputStream out = new FileOutputStream(destination)) {  //try-with-resurce
	 int b;
	 while((b = in.read()) != -1) {
	 out.write(b);
 } 
 
------------------------THE BUFFEREDINPUTSTREAM AND BUFFEREDOUTPUTSTREAM CLASSES --------------------------------
Per migliorare il vecchio esempio ora basta fare un wrapping delle vecchie classi con queste.
Instead of reading the data one byte at a time, we use the underlying read(byte[]) method of BUFFEREDINPUTSTREAM, which returns the number of bytes read into the provided byte array.
The length value returned tells us how many of the bytes in the array were actually read from the file. The remaining bytes of the array will be filled with leftover
data from the previous read that should be discarded.
The data is written into the BUFFEREDOUTPUTSTREAM using the write(byte[],int,int) method, which takes as input a byte array, an offset, and a length value, respectively. The
offset value is the number of values to skip before writing characters, and it is often set to 0. The length value is the number of characters from the byte array to write.
public class CopyBufferFileSample {
 	public static void copy(File source, File destination) throws IOException {
 	try (
 		InputStream in = new BufferedInputStream(new FileInputStream(source));
 		OutputStream out = new BufferedOutputStream(new FileOutputStream(destination))
 		){
 			byte[] buffer = new byte[1024];
 			int lengthRead;
 			while ((lengthRead = in.read(buffer)) > 0) {
 				out.write(buffer,0,lengthRead);
 				out.flush();
 			}
 		}
 	}
}
-------------------------------THE FILEREADER AND FILEWRITER CLASSES -------------------------------------------------
Entrambi come le loro varianti per i byte hanno i metodi read() and write()ma leggono valori char. Come prima il tipo di ritorno è un int e avremo -1 raggiunta la fine del file. 
The Writer class, which FileWriter inherits from, offers a write(String) method that allows a String object to be written directly to the stream.
-----------------------------THE BUFFEREDREADER AND BUFFEREDWRITER CLASSES--------------------------------------------
abbiamo metodi come readLine() and write(String)

BUFFEREDREADER
public static List<String> readFile(File source) throws IOException {
	List<String> data = new ArrayList<String>();
 	try (BufferedReader reader = new BufferedReader(new FileReader(source))) {
 		String s;
 		while((s = reader.readLine()) != null) {  //da notare che abbiamo una reference s con la nostra stringa mentre la leggiamo e controlliamo se è != null stavolta
 			data.add(s);   //salviamo i dati denttro una list<String> prima di scriverla su un file cosi magari modifichiamo qualcosa	
 		}
 	}
	return data;
}
BUFFEREDWRITER
public static void writeFile(List<String> data, File destination) throws IOException {
	try (BufferedWriter writer = new BufferedWriter(new FileWriter(destination))) {
		for(String s: data) {
			writer.write(s);   //posso scrivere direttamente tutta la riga
			writer.newLine();  //inserisco gli accapo visto che il mio codice splittava le righe per gli accap0o
		}
	}
}
Da notare che noi tutto il file lo stiamo salvando dentro sta variabile, se fosse troppo grande basterebbe sostituire il tutto con i FileReader e FileWriter cosi da non salvare nulla. 

----------------------------
Charset usAsciiCharset = Charset.forName("US-ASCII"); 
------------------------THE SERIALIZABLE INTERFACE-----------------------------------
In order to serialize objects using the java.io API, the class they belong to must implement the java.io.Serializable interface. The Serializable interface is a tagging or marker
interface, which means that it does not have any methods associated with it.
A process attempting to serialize an object will throw a NotSerializableException if the class or one of its contained classes does not properly implement the Serializable interface.
Puoi utilizzare il modificatore TRANSIENT al reference dell'oggetto cosi quel oggetto non verrà serializzato. 
Da notare che anche tutte le variabili statiche di una classe non verranno serializzate non facendo parte dell'istanza.
private static final long serialVersionUID = 1L;// è buon uso aggiungerlo alla classe
If an older version of the class is encountered during deserialization, an exception may be thrown. 	

----------------OBJECTINPUTSTREAM AND OBJECTOUTPUTSTREAM--------------
The ObjectOutputStream class includes a method to serialize the object to the stream called void writeObject(Object).
The ObjectInputStream class includes a deserialization method that returns an object called readObject().

public static List<Animal> getAnimals(File dataFile) throws IOException, ClassNotFoundException {
 List<Animal> animals = new ArrayList<Animal>();
 try (ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(dataFile)))) {
 	while(true) {
 		Object object = in.readObject();    //puo lanciaere quelle due eccezioni 
 		if(object instanceof Animal)
 			animals.add((Animal)object);
 	}	
 } catch (EOFException e) {
 // File end reached  !!! non faccio nulla 
 }
 return animals;
}

public static void createAnimalsFile(List<Animal> animals, File dataFile)throws IOException {
 try (ObjectOutputStream out = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(dataFile)))) {
 	for(Animal animal: animals)
 		out.writeObject(animal);   //puo lanciare una IOException
 	}
 }
 
We catch an EOFException, which marks the program encountering the end of the file. Notice that we don’t do anything with the exception other than finish the method
We conclude our discussion of the Object stream classes by noting that they do support reading and writing null objects. Therefore, it is important to check for null values when
reading from a serialized data stream. In our sample application, we rely on the property of the instanceof operator always to return false for null values to skip explicitly needing
to check for null values.

----------------------- UNDERSTANDING OBJECT CREATION --------------------------
Java quando deserializza va a vedere il primo costruttore non serialize che estende il nostro oggetto saltanto tutti i costruttori delle classi serializable che incontra.
Furthermore, any static variables or default initializations are ignored.

--------------------------THE PRINTSTREAM AND PRINTWRITER CLASSES----------------------
PRINTSTREAM ---> class operates on OutputStream instances and writes data as bytes
PRINTWRITER ---> class operates on Writer instances writes data as characters.
PrintWriter class even has a constructor that takes an OutputStream as input, allowing you to wrap a PrintWriter class around an OutputStream.
For the exam, you should be aware that System.out and System.err are actually PrintStream objects.
Entrambe ereditano dai rispettivi Writer e OutputStream il metodo write() che però lancia un IOException che è una checked e va quindi gestita. 
Ci sono però altri metodi in queste classi che non lanciano checked exception e sono: 

1. PRINT()
è pieno di overload con tutti i primitivi di java e anche Object String ecc
in generale questo metodo chiama String.valueOf() del parametro che gli passi e poi fa il write().The  valueOf() applied to an object calls the object’s toString() method or returns null if the object is not set.
 
 PrintWriter out = new PrintWriter("zoo.log");
 out.print(5); // PrintWriter method
 out.write(String.valueOf(5)); // Writer method
 
 out.print(2.0); // PrintWriter method
 out.write(String.valueOf(2.0)); // Writer method
 
 Animal animal = new Animal();
 out.print(animal); // PrintWriter method
 out.write(animal==null ? "null": animal.toString()); // Writer method 
 Quindi potremmo farlo anche tutto col write() del Printwriter ma abbiamo la convenience di un metodo che ci trasforma tutto in stringa per noi. 
 
2.  PRINTLN()
Virtually identical to the print() methods, except that they insert a line break after the String value is written. 
The classes also include a version of println() that takes no arguments, which terminates the current line by writing a line separator.

3. FORMAT() AND PRINTF()
Like the String.format() methods discussed in Chapter 5 , the format() method in PrintStream and PrintWriter takes a String , an optional locale, and a set of arguments, and it writes a formatted String to the stream based on the input.
In other words, it is a convenience method for formatting directly to the stream. 
e print f è esattamente la stesa cosa infatti internamente chiama format()

import java.io.*;
public class PrintWriterSample {
 public static void main(String[] args) throws IOException {
 	File source = new File("zoo.log");
 	try (PrintWriter out = new PrintWriter(
 		new BufferedWriter(new FileWriter(source)))) {
 		out.print("Today's weather is: ");
 		out.println("Sunny");
 		out.print("Today's temperature at the zoo is: ");
 		out.print(1/3.0);
 		out.println('C');
 		out.format("It has rained 10.12 inches this year");
 		out.println();
 		out.printf("It may rain 21.2 more inches this year");
 	}
 }
}

Today's weather is: Sunny
Today's temperature at the zoo is: 0.3333333333333333C
It has rained 10.12 inches this year
It may rain 21.2 more inches this year

----------------- INTERACTING WITH USERS  ---------------------------
import java.io.Console;
public class ConsoleSample {
 	public static void main(String[] args) {
 		Console console = System.console();
 		if(console != null) {
 			String userInput = console.readLine();
 			console.writer().println ("You entered the following: "+userInput);
 		}
 	}
}

--------------------READER() AND WRITER()---------------------
The Console class provides access to an instance of Reader and PrintWriter using the methods reader() and writer(), respectively.
-------------------FORMAT() AND PRINTF()-----------------------
Per scrivere puoi usare il PrintWriter writer() come detto prima oppure usare il metodo format(String,Object...) direttamente.
Da notale che il Console definisce solo un tipo di format() e non è quello che puo prendere opzionalmente un Locale in questo modo usa sempre il locale di default per formattare le stringhe inserite. 
Naturalmente dalla Console puoi sempre tirarti fuori un Writer e chiamare printf o format su quello (ti ricordo che sono identici cambia solo il nome del metodo)

Console console = System.console();
console.writer().format(new Locale("fr", "CA"),"Hello World"); 

public static void main(String[] args) throws NumberFormatException, IOException {
	Console console = System.console();
 	if(console == null) {
 		throw new RuntimeException("Console not available");
 	} else {
 		console.writer().println("Welcome to Our Zoo!");
 		console.format("Our zoo has 391 animals and employs 25 people.");
 		console.writer().println();
 		console.printf("The zoo spans 128.91 acres.");
 	}
}
------------------------FLUSH()-----------------------------------
The flush() method forces any buffered output to be written immediately. 
----------------------READLINE()------------------------------------
The basic readLine() method retrieves a single line of text from the user, and the user presses the Enter key to terminate it.
The Console class also supports an overloaded version of the readLine() method with the signature readLine(String format, Object... args), which displays a formatted prompt to the user prior to accepting text.

public class ConsoleReadInputSample {
	public static void main(String[] args) throws NumberFormatException, IOException {
 		Console console = System.console();
		if(console == null) {
 			throw new RuntimeException("Console not available");
 		} else {
 			console.writer().print("How excited are you about your trip today? ");
 			console.flush();
 			String excitementAnswer = console.readLine();
 			String name = console.readLine(“Please enter your name: “);
 			Integer age = null;
 			console.writer().print("What is your age? ");
 			console.flush();
 			BufferedReader reader = new BufferedReader(console.reader());
	 		String value = reader.readLine();
 			age = Integer.valueOf(value);
 			console.writer().println();
 			console.format("Your name is "+name);
 			console.writer().println();
 			console.format("Your age is "+age);
 			console.printf("Your excitement level is: "+excitementAnswer);
 		}
 	}
}

---------------READPASSWORD()------------------------------------------
The readPassword() method is similar to the readLine() method, except that echoing is disabled. By disabling echoing, the user does not see the text they are typing, meaning that their password is secure 
if someone happens to be looking at their screen.
Also like the readLine() method, the Console class offers an overloaded version of the readPassword() method with the signature readPassword(String format, Object...args) used for displaying a formatted 
prompt to the user prior to accepting text. Unlike the readLine() method, though, the readPassword() method returns an array of characters instead of a String.

INTERESSANTE --->
As you may remember from your OCA study material, String values are added to a shared memory pool for performance reasons in Java. This means that if a password that
a user typed in were to be returned to the process as a String, it might be available in the String pool long after the user entered it.
If the memory in the application is ever dumped to disk, it means that the password could be recovered by a malicious individual after the user has stopped using the application.
The advantage of the readPassword() method using a character array should be clear. As soon as the data is read and used, the sensitive password data in the array can be
“erased” by writing garbage data to the elements of the array. This would remove the password from memory long before it would be removed by garbage collection if a String value were used.

public class PasswordCompareSample {
	public static void main(String[] args) throws NumberFormatException, IOException {
		Console console = System.console();
 		if(console == null) {
 			throw new RuntimeException("Console not available");
 		} else {
 			char[] password = console.readPassword("Enter your password: ");
			console.format("Enter your password again: ");
			console.flush();
			char[] verify = console.readPassword();
			boolean match = Arrays.equals(password,verify);
			// Immediately clear passwords from memory
			for(int i=0; i<password.length; i++) {
				password[i]='x';
			}
			for(int i=0; i<verify.length; i++) {
				verify[i]='x';
			}
			console.format("Your password was "+(match ? "correct": "incorrect"));
		}
	}
}
################################################################################ CAPITOLO 9 ####################################################################################
-------------------- Introducing NIO.2 -------------------------------
Non-blocking I/O, or NIO for short
The basic idea is that you load the data from a file channel into a temporary buffer that, unlike byte streams, can be read forward and backward without blocking on the underlying resource.
-----------------------INTRODUCING PATH ---------------------------------
A Path object represents a hierarchical path on the storage system to a file or directory.
Spstituisce quello che prima per noi era solo File. Entrambi possono riferirsi a una directory o ad un File. 
La classe Path supporta i symbolic link. A symbolic link is a special file within an operating system that serves as a reference or pointer to another file or directory
Qui Path è un interfaccia e non una classe e per istanziare un Path dobbiamo usare un factory pattern , questo perche ci viene tornato un oggetto diverso in base al OS che stiamo utilizzando 
e quindi gia settato con le specifiche giuste per quel Sistema operativo.

NIO.2 also includes helper classes such as java.nio.file.Files, whose primary purpose is to operate on instances of Path objects.
Helper or utility classes are similar to factory classes in that they are often composed primarily of static methods that operate on a particular class.
They differ in that helper classes are focused on manipulating or creating new object 
 
 
---------------------USING THE PATHS CLASS--------------------
The simplest and most straightforward way to obtain a Path object is using the java.nio.files.Paths factory class.

 Path path1 = Paths.get("pandas/cuddly.png");  //relative file in current directory.
 Path path2 = Paths.get("c:\\zooinfo\\November\\employees.txt"); ///	 Path reference to an absolute file in a Windows-based system.
 Path path3 = Paths.get("/home/zoodirector");  // n absolute directory in a Linux or Mac-based system.

■ If a path starts with a forward slash, it is an absolute path, such as /bird/parrot.
■ If a path starts with a drive letter, it is an absolute path, such as C:\bird\emu.
■ Otherwise, it is a relative path, such as ..\eagle


You can also create a Path using the Paths class using a vararg of type String, such as Paths.get(String,String...). This allows you to create a Path from a list of String values
in which the operating system-dependent path.separator is automatically inserted between elements.
 Path path1 = Paths.get("pandas","cuddly.png");
 Path path2 = Paths.get("c:","zooinfo","November","employees.txt");
 Path path3 = Paths.get("/","home","zoodirector");

Atttento all'esame agli errori con la s 
 Paths path1 = Paths.get("/alligator/swim.txt"); // DOES NOT COMPILE   Non sto tornando un istanza dell'oggetto Factory Paths ma un istanza di Path
 Path path2 = Path.get("/crocodile/food.csv"); // DOES NOT COMPILE


URI VALUE: A uniform resource identifier (URI) is a string of characters that identify a resource.
It begins with a schema that indicates the resource type, followed by a path value. Examples of schema values include file://, http://, https://, and ftp://

 Path path1 = Paths.get(new URI("file://pandas/cuddly.png")); // THROWS EXCEPTION  AT RUNTIME Perche deve identificare un path assoluto
 Path path2 = Paths.get(new URI("file:///c:/zoo-info/November/employees.txt")); 

new URI(String) does throw a checked URISyntaxException e ci dobbiamo ricordare di fare la catch

toUri() for converting a Path instance back to a URI instance, as shown in the following sample code:
 Path path4 = Paths.get(new URI("http://www.wiley.com"));
 URI uri4 = path4.toUri(); 
------------------------ ACCESSING THE UNDERLYING FILESYSTEM OBJECT-------------------------
The FileSystem class has a protected constructor, so we use the plural FileSystems factory class to obtain an instance of FileSystem.
 
 Path path1 = FileSystems.getDefault().getPath("pandas/cuddly.png");
 Path path2 = FileSystems.getDefault().getPath("c:","zooinfo","November", "employees.txt");
 Path path3 = FileSystems.getDefault().getPath("/home/zoodirector");
 
I can connect to a remote File System 
 FileSystem fileSystem = FileSystems.getFileSystem( new URI("http://www.selikoff.net"));
 Path path = fileSystem.getPath("duck.txt");
---------------------------BACKWARD COMPATIBILITY-------------------------------------

 File file = new File("pandas/cuddly.png");
 Path path = file.toPath();    //TOPATH
For backward compatibility, the Path interface also contains a method toFile() to return a File instance:
 Path path = Paths.get("cuddly.png");
 File file = path.toFile();    //TOFILE
-------------------
Enum
1. NOFOLLOW_LINKS 
Usage: Test file existing - Read file data - Copy file - Move file
Description: If provided, symbolic links when encountered will not be traversed. Useful for performing operations on symbolic links themselves rather than their target.
2. FOLLOW_LINKS 
Usage: Traverse a directory tree
Description: If provided, symbolic links when encountered will be traversed.
3. COPY_ATTRIBUTES 
Usage: Copy file
Description: If provided, all metadata about a file will be copied with it.
4. REPLACE_EXISTING 
Usage: Copy file - Move file
Description: If provided and the target file exists, it will be replaced; otherwise, if it is not provided, an exception will be thrown if the file already exists.
5. ATOMIC_MOVE 
Usage: Move file 
Description: The operation is performed in an atomic manner within the file system, ensuring that any process using the file sees only a complete record. Method using it may throw an exception
if the feature is unsupported by the file system. If the file system does not support this feature, an AtomicMoveNotSupportedException will be thrown.

----------------  USING PATH OBJECTS --------------------
La maggior parte dei metodi di Path tornano a loro volta un oggetto Path cosi da poter esserte semplicemente legati.

1.toString() 
The first method, toString(), returns a String representation of the entire path .
2.getNameCount() and getName(int)
are often used in conjunction to retrieve the number of elements in the path and a reference to each element, respectively.
 
 Path path = Paths.get("/land/hippo/harry.happy");
 System.out.println("The Path Name is: "+path);
 for(int i=0; i<path.getNameCount(); i++) {
	System.out.println(" Element "+i+" is: "+path.getName(i));
 }
 
The Path Name is: /land/hippo/harry.happy
 Element 0 is: land
 Element 1 is: hippo
 Element 2 is: harry.happy

 Vediamo che il root non viene dichiarato infatti path.getNameCount() sul root ci da 0. 
 
3. Path  getFileName()
returns a Path instance representing the filename, which is the farthest element from the root.
4. Path getParent()
returns a Path instance representing the parent path or null if there is no such parent. If the instance of the Path object is relative, this method will stop at the top-level element 
defined in the Path object. In other words, it will not traverse outside the working directory to the file system root.
5. Path getRoot()
returns the root element for the Path object or null if the Path object is relative.


import java.nio.file.*;
public class PathFilePathTest {

 public static void printPathInformation(Path path) {
 	System.out.println("Filename is: "+path.getFileName());
 	System.out.println("Root is: "+path.getRoot());
 	Path currentParent = path;
 	while((currentParent = currentParent.getParent()) != null) {
 		System.out.println(" Current parent is: "+currentParent);
 	}	
 }
 
 public static void main(String[] args) {
 	printPathInformation(Paths.get("/zoo/armadillo/shells.txt"));
 	System.out.println();
 	printPathInformation(Paths.get("armadillo/shells.txt"));
 }
}

Filename is: shells.txt
Root is: /
 Current parent is: /zoo/armadillo
 Current parent is: /zoo
 Current parent is: /
 
 
 Filename is: shells.txt
Root is: null
 Current parent is: armadillo
  
6. boolean isAbsolute()
returns true if the path the object references is absolute and false if the path the object references is relative
System.out.println(Paths.get("/stripes/zebra.exe").isAbsolute());  // true on Linux false on Windows 
System.out.println(Paths.get("c:/goats/Food.java").isAbsolute());   // true on Windows false on Linux
7.Path  toAbsolutePath()
converts a relative Path object to an absolute Path object by joining it to the current working directory. If the Path object is already absolute, then the method just returns an equivalent copy.

8. Path subpath(int,int) 
returns a relative subpath of the Path object, referenced by an inclusive start index and an exclusive end index. It is useful for constructing a new
relative path from a particular parent path element to another parent path element.

Path path = Paths.get("/mammal/carnivore/raccoon.image");
System.out.println("Path is: "+path);                                  Path is: /mammal/carnivore/raccoon.image
System.out.println("Subpath from 0 to 3 is: "+path.subpath(0,3));      Subpath from 0 to 3 is: mammal/carnivore/raccoon.image
System.out.println("Subpath from 1 to 3 is: "+path.subpath(1,3));      Subpath from 1 to 3 is: carnivore/raccoon.image
System.out.println("Subpath from 1 to 2 is: "+path.subpath(1,2));      Subpath from 1 to 2 is: carnivore

System.out.println("Subpath from 0 to 4 is: "+path.subpath(0,4)); // THROWS EXCEPTION AT RUNTIME
System.out.println("Subpath from 1 to 1 is: "+path.subpath(1,1)); // THROWS EXCEPTION AT RUNTIME
Quindi subpath non tiene conto del nodo root

-----------------USING PATH SYMBOLS ----------------------------
.  A reference to the current directory
.. A reference to the parent of the current directory
For example, the path value ../bear.txt refers to a file named bear.txt in the parent of the current directory. Likewise, the path value ./penguin.txt refers to a file named
penguin.txt in the current directory. 


9. relativize()
The Path interface provides a method relativize(Path) for constructing the relative 
path from one Path object to another.

Path path1 = Paths.get("fish.txt");
Path path2 = Paths.get("birds.txt");
System.out.println(path1.relativize(path2));
System.out.println(path2.relativize(path1));
The code snippet produces the following output when executed:
..\birds.txt
..\fish.txt

Path path3 = Paths.get("E:\\habitat");
Path path4 = Paths.get("E:\\sanctuary\\raven");
System.out.println(path3.relativize(path4));
System.out.println(path4.relativize(path3));
This code snippet produces the following output when executed:
..\sanctuary\raven
..\..\habitat

The relativize() method requires that both paths be absolute or both relative, and it will throw an IllegalArgumentException if a relative path value is mixed with anabsolute path value.
Path path3 = Paths.get("c:\\primate\\chimpanzee");
Path path4 = Paths.get("d:\\storage\\bananas.txt");
path3.relativize(path4); // THROWS EXCEPTION AT RUNTIME
Solo su windows se faccio relativize devono far parte della stessa root.

10. Path resolve(Path) 
method for creating a new Path by joining an existing path to the current path.

final Path path1 = Paths.get("/cats/../panther");
final Path path2 = Paths.get("food");
System.out.println(path1.resolve(path2));
The code snippet generates the following output:
/cats/../panther/food    // come anche per relativize() se i punti c'erano rimangono a meno che non chiamo normalize()

final Path path1 = Paths.get("/turkey/food");
final Path path2 = Paths.get("/tiger/cage");
System.out.println(path1.resolve(path2));

/tiger/cage             //se sono due absolute prende solo il secondo

11.  normalize()
method to eliminate the redundancies in the path.

Path path3 = Paths.get("E:\\data");
Path path4 = Paths.get("E:\\user\\home");
Path relativePath = path3.relativize(path4);
System.out.println(path3.resolve(relativePath));

E:\data\..\user\home

System.out.println(path3.resolve(relativePath).normalize());
This modified last line of code nicely produces our original path value:
E:\user\home

Like relativize(), the normalize() method does not check that the file actually exists. 
12.  toRealPath()
The  method takes a Path object that may or may not point to an existing file within the file system, and it returns a reference to a real path within the file system.
It throws a checked IOException at runtime if the file cannot be located.
The toRealPath() method performs additional steps, such as removing redundant path elements. In other words, it implicitly calls normalize() on the resulting absolute path.

------------------------ INTERACTING WITH FILES ---------------------------
Unlike the methods in the Path and Paths class, most of the options within the Files class will throw an exception if the file to which the Path refers does not exist.

ATTENZIONE 
As you saw with Collection vs. Collections in Chapter 3 and Path vs. Paths earlier in this chapter, Java is fond of singular names for container classes and plural names
for factory and helper classes. In this situation, though, the NIO.2 Files helper class is in no way related to the File class, as the Files class operates on Path instances, not
File instances. Keep in mind that File belongs to the legacy java.io API, while Files belongs to the NIO.2 API.

--------------------- EXISTS()----------------------
The Files.exists(Path) method takes a Path object and returns true if, and only if, it references a file that exists in the file system.
 
--------------------Files.isSameFile(Path,Path)-----------------------------
The Files.isSameFile(Path,Path) method is useful for determining if two Path objects.Despite the name, the method also determines if two Path objects refer to the same directory.
Prima va a fare un controllo superficiale tra i due con equals() se sono uguali apposto cosi. Altrimenti va a cercare il verp path dei due e se non trova i file va in errore. 

System.out.println(Files.isSameFile(Paths.get("/user/home/cobra"),Paths.get("/user/home/snake")));  //true perche combra è un symbolink link to snake 
System.out.println(Files.isSameFile(Paths.get("/user/tree/../monkey"), Paths.get("/user/monkey"))); //true  
System.out.println(Files.isSameFile(Paths.get("/leaves/./giraffe.exe"), Paths.get("/leaves/giraffe.exe"))); // true  
System.out.println(Files.isSameFile(Paths.get("/flamingo/tail.data"), Paths.get("/cardinal/tail.data"))) //false
  
-----------------createDirectory() and createDirectories()---------------------
I due metodi che prima chiamavo mkdir e mkdirs. Il primo mi crea un directory e il seconso uguale. Entrambi possono lanciare delle eccezioni. Sopratutto createDirectory() che se non esiste il 
padre della directory che sto creando va in errore mentre createDirectories() crea tutte le directory anche quelle mancanti. 
Entrambe hanno un parametro opzionale  FileAttribute<?>  con cui possiamo passare i file da instanziare in quelle directory appena create. 

---------------------- copy() ------------------------------------------
Files.copy(Path,Path), which copies a file or directory from one location to another.
The copy() method throws the checked IOException, such as when the file or directory does not exist or cannot be read.

Files.copy(Paths.get("/panda"), Paths.get("/panda-save"));
By default, copying files and directories will traverse symbolic links, although it will not overwrite a file or directory if it already exists, nor will it copy file attributes.
These behaviors can be altered by providing the additional options NOFOLLOW_LINKS, REPLACE_EXISTING, and COPY_ATTRIBUTES, respectively, as discussed earlier in the chapter.

 // Copy stream data to file
 Files.copy(is, Paths.get("c:\\mammals\\wolf.txt"));  // da un is a un file, ha anche un versione overloaded in cui il path lo possiamo scrivere con i singoli elementi.
 // Copy file data to stream
 Files.copy(Paths.get("c:\\fish\\clown.xsl"), out)   // non ha una versione overloaded 
 
------------------move()---------------------------------
The Files.move(Path,Path) method moves or renames a file or directory within the file system. Like the copy() method, the move() method also throws the checked IOException
in the event that the file or directory could not be found or moved. 

 Files.move(Paths.get("c:\\zoo"), Paths.get("c:\\zoo-new"));  //rename
 Files.move(Paths.get("c:\\user\\addresses.txt"), Paths.get("c:\\zoo-new\\addresses.txt"));

Posso spostare una directory piena solo se sono sullo stesso drive. 

---------------------- delete() and deleteIfExists() -----------------
 The FILES.DELETE(PATH) method deletes a file or empty directory within the fi le system. The delete() method throws the checked IOException under a variety of circumstances.
For example, if the path represents a non-empty directory, the operation will throw the runtime DirectoryNotEmptyException . If the target of the path is a symbol link, then the
symbolic link will be deleted, not the target of the link. 
   
 The boolean DELETEIFEXISTS(PATH) method is identical to the delete(Path) method, except that it will not throw an exception if the file or directory does not exist, but instead it will
return a boolean value of false . It will still throw an exception if the file or directory does exist but fails, such as in the case of the directory not being empty. 
-------------------  newBufferedReader() and newBufferedWriter() ------------------------------------
Files.newBufferedReader(Path,Charset)

 Path path = Paths.get("/animals/gopher.txt");
 try (BufferedReader reader = Files.newBufferedReader( path, Charset.forName("US-ASCII"))) {...}

Files.newBufferedWriter(Path,Charset)

 Path path = Paths.get("/animals/gorilla.txt");
 try (BufferedWriter writer = Files.newBufferedWriter(path, Charset.forName("UTF-16"))) {
 writer.write("Hello World");}

------------------- readAllLines() ----------------------------------------
The Files.readAllLines() method reads all of the lines of a text file and returns the results as an ordered List of String values.
Esiste anche la versione col Charset come parametro in piu. Naturalmento puo lanciare una IOException.

final List<String> lines = Files.readAllLines(path);
Visto che carica tutto in memoria potremmo avere un  OutOfMemoryError. 

---------------------------------------------------UNDERSTANDING FILE ATTRIBUTES----------------------------------------------
Files.isDirectory(Path c) torna true se c è una directory, per alcuni SO anche il /txt.pdf puo essere una directory. SE gli passo un symbolic link è true se punta ad unaa directory.

Files.isRegularFile(Path c)  true se file, se gli passo symbolic link true se punta ad un file 

Files.isSymbolicLink(Path c ) true se è un symbolic Link a prescindere se quello che sto puntando esiste. 
DA notare che NON LANCIANO errori se non esistono i path che gli passo. 

Files.isHidden(Paths.get("/walrus.txt"))  puo lanciare ecezione IOEXCEPTION

Files.isReadable(Paths.get("/seal/baby.png")));  // true if  exists and its contents are readable, based on the permission rules of the underlying file system NON lancia 
Files.isExecutable(Paths.get("/seal/baby.png"))); // true if  is marked executable within the file system   NON lancia 

Files.size(Paths.get("/zoo/c/animals.txt")) LANCIA un IOEXCEPTION , vale per i file se chiamato su directory non si sa

FileTime Files.getLastModifiedTime(Path) //  the FileTime result have toMillis() method that returns the epoch time.
e Files.setLastModifiedTime(Path,FileTime)  // lanciano entrambe IOException // FileTime.fromMillis(System.currentTimeMillis() puo essere usato come parametro

UserPrincipal Files.getOwner(Path)  throw IOException
Files.setOwner(Path,UserPrincipal)  throw IOException

 UserPrincipal owner = FileSystems.getDefault().getUserPrincipalLookupService().lookupPrincipalByName("jane"); 
  Per prenderci l'user di qualcuno ci serve prima l'istanza del fylesystem poi ci istanziamo la classe helper UserPrincipalLookupService e su quella chiamiamo lookupPrincipalByName().
 UserPrincipal owner = path.getFileSystem().getUserPrincipalLookupService().lookupPrincipalByName("jane");
  La stessa cosa ma partendo da un istanza di un path.
  
------------------------------------------------IMPROVING ACCESS WITH VIEWS-------------------------------------------------------------------
A view is a group of related attributes for a particular file system type. A file may support multiple views, allowing you to retrieve and update various sets of information about the file.
Chiamare 20 volte per prendersi 20 atttribbuti dai file ppuo essere  costoso, meglio fare una sola chiamata e prenderseli tutti e formare una view. 
 Files.readAttributes(), returns a read-only view
 Files.getFileAttributeView(), eeturns a editable view 
 Entrambe lanciano IOException, come per esempio quando cerchiamo di leggere attributi di Linux su Windows viene lanciato un UnsupportedOperationException.
 

1 Attributes Class -> BasicFileAttributes || View Class ->  BasicFileAttributeView 
  Basic set of attributes supported by all file systems
2 Attributes Class -> DosFileAttributes || View Class ->  DosFileAttributeView 
  Attributes supported by DOS/ Windows-based systems
3 Attributes Class -> PosixFileAttributes || View Class ->  PosixFileAttributeView 
Attributes supported by POSIX systems, such as UNIX, Linux, Mac, and so on

Per l'esame dobbiamo solo conoscere la prima riga le altre tanto estendono la prima quindi avranno gli stessi metodi e comportamenti li segnaliamo cosi sai cosa sono. 
 LEGGERE ATTRIBUTI 
 Files.readAttributes(Path,Class<A>)

 Path path = Paths.get("/turtles/sea.txt");
 BasicFileAttributes data = Files.readAttributes(path, BasicFileAttributes.class);
 System.out.println("Is path a directory? "+data.isDirectory());
 System.out.println("Is path a regular file? "+data.isRegularFile());
 System.out.println("Is path a symbolic link? "+data.isSymbolicLink());
 System.out.println("Creation date/time: "+data.creationTime());
 System.out.println("Last modified date/time: "+data.lastModifiedTime());
 System.out.println("Last accessed date/time: "+data.lastAccessTime());
 
 Ci sono metodi che non abbiamo visto e sono 
 The isOther() che va a controllare se un path non è una directorye nemmeno un file , su altri SO possono essere anche altre cose. 
 The lastAccessTime() and creationTime() methods return other date/time information about the file.
 The fileKey() method returns a file system value that represents a unique identifier for the file within the file system or null if it is not supported by the file system.
 MODIFICARE ATTRIBUTI 
 Files.getFileAttributeView(Path,Class<V>)
 
 Path path = Paths.get("/turtles/sea.txt");
 BasicFileAttributeView view = Files.getFileAttributeView(path,BasicFileAttributeView.class);
 BasicFileAttributes data = view.readAttributes();
 FileTime lastModifiedTime = FileTime.fromMillis(data.lastModifiedTime().toMillis()+10_000);
 view.setTimes(lastModifiedTime,null,null);
 
 -> setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime) in the BasicFileAttributeView class
  The NIO.2 API allows us to pass null for any date/time value that we do not wish to modify. 
  
  
------------------------------------------------------------------- NEW STREAM METHODS --------------------------------------------------------------
 The Files.walk(path) method returns a Stream<Path> object that traverses the directory in a depth-first, lazy manner.
 
  Path path = Paths.get("/bigcats");
  
	try {
		Files.walk(path)
		.filter(p -> p.toString().endsWith(".java"))
		.forEach(System.out::println);
	} catch (IOException e) {
	 	// Handle file I/O exception...
 
 /bigcats/version1/backup/Lion.java
 /bigcats/version1/Lion.java
 /bigcats/version1/Tiger.java
 /bigcats/Lion.java
 
By default, the method iterates up to Integer.MAX_VALUE directories deep, although there is an overloaded version of walk(Path,int) that takes a maximum directory depth integer value as the second parameter.
In practice, you may want to set a limit to prevent your application from searching too deeply on a large directory structure and taking too much time.
 NIO.2 offers the FOLLOW_LINKS option as a vararg to the walk() method attentoperò perche se hai un symbolic link sotto di qualche directory che ti riporta alla tua directory ptincipale 
 e tu hai impostato di seguire i Links allora potresti avere una siuazione ciclica e una exception vberebbe lanciata la  FileSystemLoopException. 
 
 RICERCA
Files.find(Path,int,BiPredicate) , ricerca quialcosa col bipredicate e devi definire il livello di depth , supporta anche lui il  FOLLOW_LINK. 
I due parametri del Bipredicate sono: Path and BasicFileAttributes

Path path = Paths.get("/bigcats");
long dateFilter = 1420070400000l;
try {
    Stream<Path> stream = Files.find(path, 10,
    (p,a) -> p.toString().endsWith(".java") && a.lastModifiedTime().toMillis()>dateFilter); // sto usando il BasicFileAttributes
    stream.forEach(System.out::println);
} catch (Exception e) {
 // Handle file I/O exception...
}


LISTA DI FILE 
try {
  Path path = Paths.get("ducks");
  Files.list(path)  // con questo abbiamo la lista delle cose che ci sono nel path sotto forma di stream per solo 1 livello 
   .filter(p -> !Files.isDirectory(p))
   .map(p -> p.toAbsolutePath())
   .forEach(System.out::println);
} catch (IOException e) {
 // Handle file I/O exception...
}
Fa insomma quello che faceva File.listFiles() ma con gli stream. 

PRINT DEI CONTENUTI DI UN FILE

Prima avevamo visto d Files.readAllLines()che però se il file è troppo grande riempie la memoria. 
Stream<String>  Files.lines(Path) 
Questo metodo fa la  stessa cosa ma in metodo lazy cioe solo parte del file alla volta viene memorizzata.


Path path = Paths.get("/fish/sharks.log");
try {
 	System.out.println(Files.lines(path)
 	.filter(s -> s.startsWith("WARN "))
 	.map(s -> s.substring(5))
 	.collect(Collectors.toList()));
} catch (IOException e) {
 // Handle file I/O exception...
}

Per l'esame della nostra classe helper Files dobbiamo conoscere entrambi i metodi readAllLines() e lines() e quale torna uno stream e quale una collection. 
1Files.readAllLines(Paths.get("birds.txt")).forEach(System.out::println);
2Files.lines(Paths.get("birds.txt")).forEach(System.out::println);
Visto che forEach c'è anche per la collection vediamo che entrambe le righe compilano solo che 
la 1 usa readAllLines torna quindi una Collection e carica tutto il  file birds.txt in memoria 
2 invece usa lines() torna uno stream e legge il file birds.txt in modo lazy per parti. 