########################################################################################### CAPITOLO 8 ##############################################################################################
----------------------------------------- FILE --------------------------------------------
The File class is used to read information about existing fi les and directories, list the contents of a directory, and create/delete files and directories.
The File class cannot read or write data within a file, although it can be passed as a reference to many stream classes to read or write data.

The ABSOLUTE PATH of a file or directory is the full path from the root directory to the file or directory, including all subdirectories that contain the file or directory.
Alternatively, the relative path of a file or directory is the path from the current working directory to file or directory.

/home/smith/data/zoo.txt    ABSOLUTE PATH
 
The following is a relative path to the same file, assuming the userâ€™s current directory was set to /home/smith.

data/zoo.txt                RELATIVE PATH
Unixbased systems use  / for paths, whereas Windows-based systems use the backslash \ character. 
Java offers two options to retrieve the local separator character: 
a system property and a static variable defined in the File class. 

public class FileSample {
	public static void main(String[] args) {
	File file = new File("/home/smith/data/zoo.txt");
	System.out.println(file.exists());
    } 
}

File parent = new File("/home/smith");
File child = new File(parent,"data/zoo.txt");   // se parent Ã¨ null java lo ignora e utilizza solo il secondo
Ã© equivalente  quello di prima.

------------------ COMMONLY USED JAVA.IO.FILE METHODS -------------------------------------------------
1 exists() Returns true if the file or directory exists.
2 getName() Returns the name of the file or directory denoted by this path.
3 getAbsolutePath() Returns the absolute pathname string of this path.
4 isDirectory() Returns true if the file denoted by this path is a directory.
5 isFile() Returns true if the file denoted by this path is a file.
6 length() Returns the number of bytes in the file. For performance reasons, the file system may allocate more bytes on disk than the file actually uses.
7 lastModified() Returns the number of milliseconds since the epoch when the file was last modified.
8 delete() Deletes the file or directory. If this pathname denotes a directory, then the directory must be empty in order to be deleted.
9 renameTo(File) Renames the file denoted by this path.
10 mkdir() Creates the directory named by this path.
11 mkdirs() Creates the directory named by this path including any nonexistent parent directories.
12 getParent() Returns the abstract pathname of this abstract pathnameâ€™s parent or null if this pathname does not name a parent directory.
13 listFiles() Returns a File[] array denoting the files in the directory.

----------------- INTRODUCING STREAMS ----------------------------------------------------------------------
Note that the I/O streams that we discuss in this chapter are data streams and completely unrelated to the new Stream API that you saw.

a STRAM is a list of data elements presented sequentially. Each type of stream segments data into a â€œwaveâ€� or â€œblockâ€� in a particular way.
Nearly all are built on top of reading or writing an individual byte or an array of bytes at a time. The reasoning behind more high-order streams is for convenience as well as performance.

---------------------------- BYTE STREAMS VS. CHARACTER STREAMS ----------------------------------------------
Fra i vari Stram noteremo quelli che nel nome hnano STREAM e quelli che hanno READER/WRITER, ecco le differenze:
1. The stream classes are used for inputting and outputting all types of binary or byte data.
2. The reader and writer classes are used for inputting and outputting only character and String data.
It is important to remember that even though readers/writers do not contain the word Stream in their class name, they are still in fact streams!

The java.io API is structured such that all of the stream classes have the word InputStream or OutputStream in their name, while all Reader/Writer classes have either Reader or Writer in their name.
Attento ai nomi dei vari Stream ti aiuteranno a capirne la logica senza conoscerli necessariamente. 

Tutte le classi che Di solito hanno InputStreamQualcosa hano anche OutputStreamQualcosa quindi anche le ReaderQualcosa avranno uun WriterQualcosa. 
A questa regola fanno ecezione: 
1 PrintWriter has no accompanying PrintReader class. 
2 PrintStream class has no corresponding InputStream class.



try (
 BufferedReader bufferedReader = new BufferedReader(
 new FileReader("zoo-data.txt"))) {
 System.out.println(bufferedReader.readLine());
}

In this example, FileReader is the low-level stream reader, whereas BufferedReader is the high-level stream that takes a FileReader as input. Many operations on the high-level stream
pass through as operations to the underlying low-level stream, such as read() or close().
Other operations override or add new functionality to the low-level stream methods. The highlevel stream adds new methods, such as readLine(), as well as performance enhancements for
reading and filtering the low-level data. 

try (ObjectInputStream objectStream = new ObjectInputStream(
 new BufferedInputStream(
 new FileInputStream("zoo-data.txt")))) {
 System.out.println(objectStream.readObject());
}

Buffered classes read or write data in groups, rather than a single byte or character at a time.
 ------------------------------ STREAM BASE CLASSES --------------------------------------------------------------------------
 Classi Astratte:  InputStream, OutputStream, Reader, and Writer
 Per convenienza java ha mantenuto il nome di queste classi nelle sottoclassi come suffisso. For example, ObjectInputStream ends with InputStream, meaning it has InputStream as an inherited parent class.
 Most stream classes in java.io follow this pattern, PrintStream, which is an OutputStream, does not.
 
new BufferedInputStream(new FileReader("zoo-data.txt")); // DOES NOT COMPILE
new BufferedWriter(new FileOutputStream("zoo-data.txt")); // DOES NOT COMPILE
new ObjectInputStream(new FileOutputStream("zoo-data.txt")); // DOES NOT COMPILE
new BufferedInputStream(new InputStream()); // DOES NOT COMPILE Perche InputStream Ã¨ una classe abstract. 
Attento all'esame cercheranno di fregarti combinando tipi diversi di classi non compatibili.



â–  A class with the word InputStream or OutputStream in its name is used for reading or writing binary data, respectively.
â–  A class with the word Reader or Writer in its name is used for reading or writing character or string data, respectively.
â–  Most, but not all, input classes have a corresponding output class.
â–  A low-level stream connects directly with the source of the data.
â–  A high-level stream is built on top of another stream using wrapping.
â–  A class with Buffered in its name reads or writes data in groups of bytes or characters and often improves performance in sequential file systems.



Class Name        Low/High   Level Description
InputStream         N/A      The abstract class all InputStream classes inherit from
OutputStream        N/A      The abstract class all OutputStream classes inherit from
Reader              N/A      The abstract class all Reader classes inherit from
Writer              N/A      The abstract class all Writer classes inherit from
FileInputStream     Low      Reads file data as bytes
FileOutputStream    Low      Writes file data as bytes
FileReader          Low      Reads file data as characters
FileWriter          Low      Writes file data as characters
BufferedReader      High     Reads character data from an existing Reader in a buffered manner, which improves efficiency and performance
BufferedWriter      High     Writes character data to an existing Writer in a buffered manner, which improves efficiency and performance
ObjectInputStream   High     Deserializes primitive Java data types and graphs of Java objects from an existing InputStream
ObjectOutputStream  High     Serializes primitive Java data types and graphs of Java objects to an existing OutputStream
InputStreamReader   High     Reads character data from an existing InputStream
OutputStreamWriter  High     Writes character data to an existing OutputStream
PrintStream         High     Writes formatted representations of Java objects to a binary stream
PrintWriter         High     Writes formatted representations of Java objects to a text-based output stream


----------------CLOSING THE STREAM --------------------------------
Since streams are considered resources, it is imperative that they be closed after they are used lest they lead to resource leaks.

----------------FLUSHING THE STREAM ---------------------------------
Quando scriviamo dei dati su un OutputStream questo non vuol dire che i dati vengono direttamente scritti sul file. Spesso vengono salvati in una memoria di chace (cambia in base al SO). 
E se il sistema termina in modo inaspettato quello che avevamo scritto sull'ouputStream non arriva mai al file perche rimarrÃ  nella cache.
To address this, Java provides a flush() method, which requests that all accumulated data be written immediately to disk.  Unless the data that you are writing
is extremely critical, the flush() method should only be used intermittently.
----------------MARKING THE STREAM ----------------------------------

Chiamare markSupported() sullo stream per vedere se torna true e quindi vedere se è supportato meno il mark.
mark(int) delimiti per quanti bytes vuoi mantenere il sengo.Quando vuoi tornare indietro chiami  reset() e torni a dove hai messo il segno.In pratica da dove metti il mark quei dati li metti in memoria
cosi da poterli leggere di nuovo una volta chimato reset()
InputStream is = ...
System.out.print ((char)is.read()); A
if(is.markSupported()) {
	is.mark(100);
	System.out.print((char)is.read()); B
	System.out.print((char)is.read()); C
	is.reset();
}
System.out.print((char)is.read()); B
System.out.print((char)is.read()); C
System.out.print((char)is.read()); D

------------------SKIPPING OVER DATA-------------------------------
The InputStream and Reader classes also include a skip(long) method, which as you might expect skips over a certain number of bytes. It returns a long value, which indicates
the number of bytes that were actually skipped. 

InputStream is = ...  (TIGERS)
System.out.print ((char)is.read()); T
is.skip(2) IG 
is.read();  E  //vediamo che in questo caso un read non gestito è come lo skip solo che è lento sempre meglio lo skip per molti byte
System.out.print((char)is.read()); R
System.out.print((char)is.read()); S

-------------------------THE FILEINPUTSTREAM AND FILEOUTPUTSTREAM CLASSES------------------------------------
They are used to read bytes from a file or write bytes to a file, respectively. These classes include constructors that take a File object or String, representing a path to the file.
The data in a FileInputStream object is commonly accessed by successive calls to the read() method until a value of -1 is returned, indicating that the end of the stream.
The FileInputStream class also contains overloaded versions of the read() method, which take a pointer to a byte array where the data is written. The method returns an
integer value indicating how many bytes can be read into the byte array. It is also used by Buffered classes to improve performance.
A FileOutputStream object is accessed by writing successive bytes using the write(int) method. Like the FileInputStream class, the FileOutputStream also contains overloaded
versions of the write() method that allow a byte array to be passed and can be used by Buffered classes.  

try (InputStream in = new FileInputStream(source);    
	 OutputStream out = new FileOutputStream(destination)) {  //try-with-resurce
	 int b;
	 while((b = in.read()) != -1) {
	 out.write(b);
 } 
 
------------------------THE BUFFEREDINPUTSTREAM AND BUFFEREDOUTPUTSTREAM CLASSES --------------------------------
Per migliorare il vecchio esempio ora basta fare un wrapping delle vecchie classi con queste.
Instead of reading the data one byte at a time, we use the underlying read(byte[]) method of BUFFEREDINPUTSTREAM, which returns the number of bytes read into the provided byte array.
The length value returned tells us how many of the bytes in the array were actually read from the file. The remaining bytes of the array will be filled with leftover
data from the previous read that should be discarded.
The data is written into the BUFFEREDOUTPUTSTREAM using the write(byte[],int,int) method, which takes as input a byte array, an offset, and a length value, respectively. The
offset value is the number of values to skip before writing characters, and it is often set to 0. The length value is the number of characters from the byte array to write.
public class CopyBufferFileSample {
 	public static void copy(File source, File destination) throws IOException {
 	try (
 		InputStream in = new BufferedInputStream(new FileInputStream(source));
 		OutputStream out = new BufferedOutputStream(new FileOutputStream(destination))
 		){
 			byte[] buffer = new byte[1024];
 			int lengthRead;
 			while ((lengthRead = in.read(buffer)) > 0) {
 				out.write(buffer,0,lengthRead);
 				out.flush();
 			}
 		}
 	}
}
-------------------------------THE FILEREADER AND FILEWRITER CLASSES -------------------------------------------------
Entrambi come le loro varianti per i byte hanno i metodi read() and write()ma leggono valori char. Come prima il tipo di ritorno è un int e avremo -1 raggiunta la fine del file. 
The Writer class, which FileWriter inherits from, offers a write(String) method that allows a String object to be written directly to the stream.
-----------------------------THE BUFFEREDREADER AND BUFFEREDWRITER CLASSES--------------------------------------------
abbiamo metodi come readLine() and write(String)

BUFFEREDREADER
public static List<String> readFile(File source) throws IOException {
	List<String> data = new ArrayList<String>();
 	try (BufferedReader reader = new BufferedReader(new FileReader(source))) {
 		String s;
 		while((s = reader.readLine()) != null) {  //da notare che abbiamo una reference s con la nostra stringa mentre la leggiamo e controlliamo se è != null stavolta
 			data.add(s);   //salviamo i dati denttro una list<String> prima di scriverla su un file cosi magari modifichiamo qualcosa	
 		}
 	}
	return data;
}
BUFFEREDWRITER
public static void writeFile(List<String> data, File destination) throws IOException {
	try (BufferedWriter writer = new BufferedWriter(new FileWriter(destination))) {
		for(String s: data) {
			writer.write(s);   //posso scrivere direttamente tutta la riga
			writer.newLine();  //inserisco gli accapo visto che il mio codice splittava le righe per gli accap0o
		}
	}
}
Da notare che noi tutto il file lo stiamo salvando dentro sta variabile, se fosse troppo grande basterebbe sostituire il tutto con i FileReader e FileWriter cosi da non salvare nulla. 

----------------------------
Charset usAsciiCharset = Charset.forName("US-ASCII"); 
------------------------THE SERIALIZABLE INTERFACE-----------------------------------
In order to serialize objects using the java.io API, the class they belong to must implement the java.io.Serializable interface. The Serializable interface is a tagging or marker
interface, which means that it does not have any methods associated with it.
A process attempting to serialize an object will throw a NotSerializableException if the class or one of its contained classes does not properly implement the Serializable interface.
Puoi utilizzare il modificatore TRANSIENT al reference dell'oggetto cosi quel oggetto non verrà serializzato. 
Da notare che anche tutte le variabili statiche di una classe non verranno serializzate non facendo parte dell'istanza.
private static final long serialVersionUID = 1L;// è buon uso aggiungerlo alla classe
If an older version of the class is encountered during deserialization, an exception may be thrown. 	

----------------OBJECTINPUTSTREAM AND OBJECTOUTPUTSTREAM--------------
The ObjectOutputStream class includes a method to serialize the object to the stream called void writeObject(Object).
The ObjectInputStream class includes a deserialization method that returns an object called readObject().

public static List<Animal> getAnimals(File dataFile) throws IOException, ClassNotFoundException {
 List<Animal> animals = new ArrayList<Animal>();
 try (ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(dataFile)))) {
 	while(true) {
 		Object object = in.readObject();    //puo lanciaere quelle due eccezioni 
 		if(object instanceof Animal)
 			animals.add((Animal)object);
 	}	
 } catch (EOFException e) {
 // File end reached  !!! non faccio nulla 
 }
 return animals;
}

public static void createAnimalsFile(List<Animal> animals, File dataFile)throws IOException {
 try (ObjectOutputStream out = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(dataFile)))) {
 	for(Animal animal: animals)
 		out.writeObject(animal);   //puo lanciare una IOException
 	}
 }
 
We catch an EOFException, which marks the program encountering the end of the file. Notice that we don’t do anything with the exception other than finish the method
We conclude our discussion of the Object stream classes by noting that they do support reading and writing null objects. Therefore, it is important to check for null values when
reading from a serialized data stream. In our sample application, we rely on the property of the instanceof operator always to return false for null values to skip explicitly needing
to check for null values.

----------------------- UNDERSTANDING OBJECT CREATION --------------------------
Java quando deserializza va a vedere il primo costruttore non serialize che estende il nostro oggetto saltanto tutti i costruttori delle classi serializable che incontra.
Furthermore, any static variables or default initializations are ignored.

--------------------------THE PRINTSTREAM AND PRINTWRITER CLASSES----------------------
PRINTSTREAM ---> class operates on OutputStream instances and writes data as bytes
PRINTWRITER ---> class operates on Writer instances writes data as characters.
PrintWriter class even has a constructor that takes an OutputStream as input, allowing you to wrap a PrintWriter class around an OutputStream.
For the exam, you should be aware that System.out and System.err are actually PrintStream objects.
Entrambe ereditano dai rispettivi Writer e OutputStream il metodo write() che però lancia un IOException che è una checked e va quindi gestita. 
Ci sono però altri metodi in queste classi che non lanciano checked exception e sono: 

1. PRINT()
è pieno di overload con tutti i primitivi di java e anche Object String ecc
in generale questo metodo chiama String.valueOf() del parametro che gli passi e poi fa il write().The  valueOf() applied to an object calls the object’s toString() method or returns null if the object is not set.
 
 PrintWriter out = new PrintWriter("zoo.log");
 out.print(5); // PrintWriter method
 out.write(String.valueOf(5)); // Writer method
 
 out.print(2.0); // PrintWriter method
 out.write(String.valueOf(2.0)); // Writer method
 
 Animal animal = new Animal();
 out.print(animal); // PrintWriter method
 out.write(animal==null ? "null": animal.toString()); // Writer method 
 Quindi potremmo farlo anche tutto col write() del Printwriter ma abbiamo la convenience di un metodo che ci trasforma tutto in stringa per noi. 
 
2.  PRINTLN()
Virtually identical to the print() methods, except that they insert a line break after the String value is written. 
The classes also include a version of println() that takes no arguments, which terminates the current line by writing a line separator.

3. FORMAT() AND PRINTF()
Like the String.format() methods discussed in Chapter 5 , the format() method in PrintStream and PrintWriter takes a String , an optional locale, and a set of arguments, and it writes a formatted String to the stream based on the input.
In other words, it is a convenience method for formatting directly to the stream. 
e print f è esattamente la stesa cosa infatti internamente chiama format()

import java.io.*;
public class PrintWriterSample {
 public static void main(String[] args) throws IOException {
 	File source = new File("zoo.log");
 	try (PrintWriter out = new PrintWriter(
 		new BufferedWriter(new FileWriter(source)))) {
 		out.print("Today's weather is: ");
 		out.println("Sunny");
 		out.print("Today's temperature at the zoo is: ");
 		out.print(1/3.0);
 		out.println('C');
 		out.format("It has rained 10.12 inches this year");
 		out.println();
 		out.printf("It may rain 21.2 more inches this year");
 	}
 }
}

Today's weather is: Sunny
Today's temperature at the zoo is: 0.3333333333333333C
It has rained 10.12 inches this year
It may rain 21.2 more inches this year

----------------- INTERACTING WITH USERS  ---------------------------
import java.io.Console;
public class ConsoleSample {
 	public static void main(String[] args) {
 		Console console = System.console();
 		if(console != null) {
 			String userInput = console.readLine();
 			console.writer().println ("You entered the following: "+userInput);
 		}
 	}
}

--------------------READER() AND WRITER()---------------------
The Console class provides access to an instance of Reader and PrintWriter using the methods reader() and writer(), respectively.
-------------------FORMAT() AND PRINTF()-----------------------
Per scrivere puoi usare il PrintWriter writer() come detto prima oppure usare il metodo format(String,Object...) direttamente.
Da notale che il Console definisce solo un tipo di format() e non è quello che puo prendere opzionalmente un Locale in questo modo usa sempre il locale di default per formattare le stringhe inserite. 
Naturalmente dalla Console puoi sempre tirarti fuori un Writer e chiamare printf o format su quello (ti ricordo che sono identici cambia solo il nome del metodo)

Console console = System.console();
console.writer().format(new Locale("fr", "CA"),"Hello World"); 

public static void main(String[] args) throws NumberFormatException, IOException {
	Console console = System.console();
 	if(console == null) {
 		throw new RuntimeException("Console not available");
 	} else {
 		console.writer().println("Welcome to Our Zoo!");
 		console.format("Our zoo has 391 animals and employs 25 people.");
 		console.writer().println();
 		console.printf("The zoo spans 128.91 acres.");
 	}
}
------------------------FLUSH()-----------------------------------
The flush() method forces any buffered output to be written immediately. 
----------------------READLINE()------------------------------------
The basic readLine() method retrieves a single line of text from the user, and the user presses the Enter key to terminate it.
The Console class also supports an overloaded version of the readLine() method with the signature readLine(String format, Object... args), which displays a formatted prompt to the user prior to accepting text.

public class ConsoleReadInputSample {
	public static void main(String[] args) throws NumberFormatException, IOException {
 		Console console = System.console();
		if(console == null) {
 			throw new RuntimeException("Console not available");
 		} else {
 			console.writer().print("How excited are you about your trip today? ");
 			console.flush();
 			String excitementAnswer = console.readLine();
 			String name = console.readLine(“Please enter your name: “);
 			Integer age = null;
 			console.writer().print("What is your age? ");
 			console.flush();
 			BufferedReader reader = new BufferedReader(console.reader());
	 		String value = reader.readLine();
 			age = Integer.valueOf(value);
 			console.writer().println();
 			console.format("Your name is "+name);
 			console.writer().println();
 			console.format("Your age is "+age);
 			console.printf("Your excitement level is: "+excitementAnswer);
 		}
 	}
}

---------------READPASSWORD()------------------------------------------
The readPassword() method is similar to the readLine() method, except that echoing is disabled. By disabling echoing, the user does not see the text they are typing, meaning that their password is secure 
if someone happens to be looking at their screen.
Also like the readLine() method, the Console class offers an overloaded version of the readPassword() method with the signature readPassword(String format, Object...args) used for displaying a formatted 
prompt to the user prior to accepting text. Unlike the readLine() method, though, the readPassword() method returns an array of characters instead of a String.

INTERESSANTE --->
As you may remember from your OCA study material, String values are added to a shared memory pool for performance reasons in Java. This means that if a password that
a user typed in were to be returned to the process as a String, it might be available in the String pool long after the user entered it.
If the memory in the application is ever dumped to disk, it means that the password could be recovered by a malicious individual after the user has stopped using the application.
The advantage of the readPassword() method using a character array should be clear. As soon as the data is read and used, the sensitive password data in the array can be
“erased” by writing garbage data to the elements of the array. This would remove the password from memory long before it would be removed by garbage collection if a String value were used.

public class PasswordCompareSample {
	public static void main(String[] args) throws NumberFormatException, IOException {
		Console console = System.console();
 		if(console == null) {
 			throw new RuntimeException("Console not available");
 		} else {
 			char[] password = console.readPassword("Enter your password: ");
			console.format("Enter your password again: ");
			console.flush();
			char[] verify = console.readPassword();
			boolean match = Arrays.equals(password,verify);
			// Immediately clear passwords from memory
			for(int i=0; i<password.length; i++) {
				password[i]='x';
			}
			for(int i=0; i<verify.length; i++) {
				verify[i]='x';
			}
			console.format("Your password was "+(match ? "correct": "incorrect"));
		}
	}
}

